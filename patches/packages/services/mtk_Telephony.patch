diff -Naur ./Telephony/res/values/cm_strings.xml ./Telephony_mtk/res/values/cm_strings.xml
--- ./Telephony/res/values/cm_strings.xml	2016-07-13 01:20:53.074700000 +0700
+++ ./Telephony_mtk/res/values/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -188,7 +188,6 @@
 
     <!-- FDN settings: error message displayed in a popup (toast) -->
     <string name="fdn_invalid_number_cm">FDN wasn\'t updated because the number is empty or exceeds 20 digits.</string>
-    <string name="fdn_service_unavailable">FDN service is not available.</string>
 
     <!-- Title of the activity shown for Exporting contacts to SIM.  -->
     <string name="exportContacts">Exporting contacts to SIM card\u2026</string>
diff -Naur ./Telephony/res/values/strings.xml ./Telephony_mtk/res/values/strings.xml
--- ./Telephony/res/values/strings.xml	2016-07-13 01:20:53.074700000 +0700
+++ ./Telephony_mtk/res/values/strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -837,6 +837,7 @@
     <string name="pin2_or_fdn_invalid">FDN wasn\'t updated. The PIN2 was incorrect, or the phone number was rejected.</string>
     <!-- FDN settings: error message displayed in a popup (toast) -->
     <string name="fdn_failed">FDN operation failed.</string>
+    <string name="fdn_service_unavailable">FDN service is not available.</string>
 
     <!-- ADN related strings -->
     <!-- Placeholder text displayed while loading the list of SIM contacts -->
diff -Naur ./Telephony/res/values-af/cm_strings.xml ./Telephony_mtk/res/values-af/cm_strings.xml
--- ./Telephony/res/values-af/cm_strings.xml	2016-07-13 01:20:52.994700000 +0700
+++ ./Telephony_mtk/res/values-af/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Wagwoorde stem nie ooreen nie</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN is nie opgedateer, want die nommer is leeg of meer as 20 syfers.</string>
-  <string name="fdn_service_unavailable">FDN diens is nie beskikbaar nie.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Uitvoer kontakte na SIM-kaart\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ar/cm_strings.xml ./Telephony_mtk/res/values-ar/cm_strings.xml
--- ./Telephony/res/values-ar/cm_strings.xml	2016-07-13 01:20:53.002700000 +0700
+++ ./Telephony_mtk/res/values-ar/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">كلمتا المرور لا تتطابقان</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">لم يتم تحديث FDN لأن حقل العدد فارغ أو يتجاوز 20 رقماً.</string>
-  <string name="fdn_service_unavailable">لا تتوفر خدمة FDN.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">تصدير جهات الاتصال إلى بطاقة SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-as-rIN/cm_strings.xml ./Telephony_mtk/res/values-as-rIN/cm_strings.xml
--- ./Telephony/res/values-as-rIN/cm_strings.xml	2016-07-13 01:20:53.002700000 +0700
+++ ./Telephony_mtk/res/values-as-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">পাছৱৰ্ড মিলা নাই</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN উন্নীত কৰা হোৱা নাই কাৰণ সংখ্যা খালি আছে বা 20 টা অতিক্ৰম কৰিছে।</string>
-  <string name="fdn_service_unavailable">FDN সেৱা উপলদ্ধ নহয়।</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">SIM কাৰ্ড\u2026 লৈ যোগাযোগ ৰপ্তানি কৰি আছে</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ast-rES/cm_strings.xml ./Telephony_mtk/res/values-ast-rES/cm_strings.xml
--- ./Telephony/res/values-ast-rES/cm_strings.xml	2016-07-13 01:20:53.002700000 +0700
+++ ./Telephony_mtk/res/values-ast-rES/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -147,7 +147,6 @@
   <string name="cb_psw_dont_match">Les contraseñes nun concasen</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN nun s\'anovó porque\'l númberu ta baleru o perpasa los 20 díxitos.</string>
-  <string name="fdn_service_unavailable">El serviciu FDN nun ta disponible.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Esportando contautos a la tarxeta SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-az-rAZ/cm_strings.xml ./Telephony_mtk/res/values-az-rAZ/cm_strings.xml
--- ./Telephony/res/values-az-rAZ/cm_strings.xml	2016-07-13 01:20:53.002700000 +0700
+++ ./Telephony_mtk/res/values-az-rAZ/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">Yalnız GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">GSM/WCDMA üstünlük verilən</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN xidməti mövcud deyil.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Şəxslər SIM karta köçürülür\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-be/cm_strings.xml ./Telephony_mtk/res/values-be/cm_strings.xml
--- ./Telephony/res/values-be/cm_strings.xml	2016-07-13 01:20:53.006700000 +0700
+++ ./Telephony_mtk/res/values-be/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">Паролі та розныя</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN не абноўлены, бо нумар не набраны ці перавышае 20 лічбаў.</string>
-  <string name="fdn_service_unavailable">Служба FDN недаступная.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Экспарт кантактаў на SIM-карту\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-bg/cm_strings.xml ./Telephony_mtk/res/values-bg/cm_strings.xml
--- ./Telephony/res/values-bg/cm_strings.xml	2016-07-13 01:20:53.006700000 +0700
+++ ./Telephony_mtk/res/values-bg/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Паролите не съвпадат</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN не беше актуализирана, защото номерът е празен или превишава 20 цифри.</string>
-  <string name="fdn_service_unavailable">FDN услугата не е налична.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Експортиране на контакти в СИМ карта\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ca/cm_strings.xml ./Telephony_mtk/res/values-ca/cm_strings.xml
--- ./Telephony/res/values-ca/cm_strings.xml	2016-07-13 01:20:53.006700000 +0700
+++ ./Telephony_mtk/res/values-ca/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Les contrasenyes no coincideixen</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">L\'FDN no ha estat actualitzat perquè el número està buit o supera els 20 dígits.</string>
-  <string name="fdn_service_unavailable">El servei FDN no està disponible.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exportant els contactes a la targeta SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-cs/cm_strings.xml ./Telephony_mtk/res/values-cs/cm_strings.xml
--- ./Telephony/res/values-cs/cm_strings.xml	2016-07-13 01:20:53.006700000 +0700
+++ ./Telephony_mtk/res/values-cs/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Hesla se neshodují</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN nebylo aktualizováno, protože číslo chybí nebo přesahuje 20 číslic.</string>
-  <string name="fdn_service_unavailable">Služba FDN není dostupná.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Export kontaktů na kartu SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-da/cm_strings.xml ./Telephony_mtk/res/values-da/cm_strings.xml
--- ./Telephony/res/values-da/cm_strings.xml	2016-07-13 01:20:53.014700000 +0700
+++ ./Telephony_mtk/res/values-da/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Adgangskoderne er ikke ens</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN blev ikke opdateret, fordi nummeret er tomt eller overstiger 20 cifre.</string>
-  <string name="fdn_service_unavailable">FDN-tjenesten er ikke tilgængelig.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Eksporterer kontakter til SIM-kort\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-de/cm_strings.xml ./Telephony_mtk/res/values-de/cm_strings.xml
--- ./Telephony/res/values-de/cm_strings.xml	2016-07-13 01:20:53.018700000 +0700
+++ ./Telephony_mtk/res/values-de/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Passwörter stimmen nicht überein</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">Rufnummernbeschränkung wurde nicht aktualisiert, da die Nummer entweder leer ist oder 20 Ziffern überschreitet.</string>
-  <string name="fdn_service_unavailable">FDN-Dienst ist nicht verfügbar.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Kontakte werden auf die SIM-Karte exportiert\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-el/cm_strings.xml ./Telephony_mtk/res/values-el/cm_strings.xml
--- ./Telephony/res/values-el/cm_strings.xml	2016-07-13 01:20:53.018700000 +0700
+++ ./Telephony_mtk/res/values-el/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Οι κωδικοί πρόσβασης δεν ταιριάζουν</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">Το FDN δεν ενημερώθηκε, επειδή ο αριθμός είναι κενός ή υπερβαίνει τα 20 ψηφία.</string>
-  <string name="fdn_service_unavailable">Η υπηρεσία FDN δεν είναι διαθέσιμη.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Εξαγωγή επαφών στην κάρτα SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-en-rAU/cm_strings.xml ./Telephony_mtk/res/values-en-rAU/cm_strings.xml
--- ./Telephony/res/values-en-rAU/cm_strings.xml	2016-07-13 01:20:53.018700000 +0700
+++ ./Telephony_mtk/res/values-en-rAU/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -108,7 +108,6 @@
   <string name="preferred_network_mode_gsm_only_choice">GSM only</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">GSM/WCDMA preferred</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN service is not available.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exporting contacts to SIM card\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-en-rIN/cm_strings.xml ./Telephony_mtk/res/values-en-rIN/cm_strings.xml
--- ./Telephony/res/values-en-rIN/cm_strings.xml	2016-07-13 01:20:53.018700000 +0700
+++ ./Telephony_mtk/res/values-en-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -145,7 +145,6 @@
   <string name="cb_psw_dont_match">Passwords do not match</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN wasn\'t updated because the number is empty or exceeds 20 digits.</string>
-  <string name="fdn_service_unavailable">FDN service is not available.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exporting contacts to SIM card\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-eo/cm_strings.xml ./Telephony_mtk/res/values-eo/cm_strings.xml
--- ./Telephony/res/values-eo/cm_strings.xml	2016-07-13 01:20:53.018700000 +0700
+++ ./Telephony_mtk/res/values-eo/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">nur GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">GSM/WCDMA plej ŝatata</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN servo ne disponeblas.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Eksporti kontaktulojn al SIM-karto\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-es/cm_strings.xml ./Telephony_mtk/res/values-es/cm_strings.xml
--- ./Telephony/res/values-es/cm_strings.xml	2016-07-13 01:20:53.022700000 +0700
+++ ./Telephony_mtk/res/values-es/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Las contraseñas no coinciden</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN no fue actualizado porqué el número está vacío o supera los 20 dígitos.</string>
-  <string name="fdn_service_unavailable">El servicio FDN no está disponible.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exportando contactos a la tarjeta SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-es-rUS/cm_strings.xml ./Telephony_mtk/res/values-es-rUS/cm_strings.xml
--- ./Telephony/res/values-es-rUS/cm_strings.xml	2016-07-13 01:20:53.022700000 +0700
+++ ./Telephony_mtk/res/values-es-rUS/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Las contraseñas no coinciden</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN no fue actualizado porque el número está vacío o supera los 20 dígitos.</string>
-  <string name="fdn_service_unavailable">El servicio FDN no está disponible.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exportando contactos a la tarjeta SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-et-rEE/cm_strings.xml ./Telephony_mtk/res/values-et-rEE/cm_strings.xml
--- ./Telephony/res/values-et-rEE/cm_strings.xml	2016-07-13 01:20:53.022700000 +0700
+++ ./Telephony_mtk/res/values-et-rEE/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">Ainult GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">Eelistatult GSM/WCDMA</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN teenus ei ole saadaval.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Ekspordin kontaktid SIM kaardile\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-eu-rES/cm_strings.xml ./Telephony_mtk/res/values-eu-rES/cm_strings.xml
--- ./Telephony/res/values-eu-rES/cm_strings.xml	2016-07-13 01:20:53.022700000 +0700
+++ ./Telephony_mtk/res/values-eu-rES/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Pasahitzak ez datoz bat</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">Ez da FDN eguneratu zenbakia hutsik dagoelako eta 20 digitu baino luzeagoa delako.</string>
-  <string name="fdn_service_unavailable">FDN zerbitzua ez dago eskuragarri.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Kontaktuak SIMera esportatzen\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-fa/cm_strings.xml ./Telephony_mtk/res/values-fa/cm_strings.xml
--- ./Telephony/res/values-fa/cm_strings.xml	2016-07-13 01:20:53.026700000 +0700
+++ ./Telephony_mtk/res/values-fa/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">تنها GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">GSM/WCDMA ترجیح داده شده</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">سرویس FDN در دسترس نمی‌باشد.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">در حال برون‌ریزی مخاطبین به سیم کارت\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-fi/cm_strings.xml ./Telephony_mtk/res/values-fi/cm_strings.xml
--- ./Telephony/res/values-fi/cm_strings.xml	2016-07-13 01:20:53.026700000 +0700
+++ ./Telephony_mtk/res/values-fi/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Salasanat eivät täsmää</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN:ää ei päivitetty koska numero on tyhjä tai pidempi kuin 20 numeroa.</string>
-  <string name="fdn_service_unavailable">FDN palvelu ei ole käytettävissä.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Viedään yhteystiedot SIM-kortille\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-fr/cm_strings.xml ./Telephony_mtk/res/values-fr/cm_strings.xml
--- ./Telephony/res/values-fr/cm_strings.xml	2016-07-13 01:20:53.026700000 +0700
+++ ./Telephony_mtk/res/values-fr/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Les mots de passe ne correspondent pas</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN non mis à jour car le numéro est vide ou dépasse 20 chiffres.</string>
-  <string name="fdn_service_unavailable">Le service FDN n\'est pas disponible.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exporter les contacts vers la carte SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-gl-rES/cm_strings.xml ./Telephony_mtk/res/values-gl-rES/cm_strings.xml
--- ./Telephony/res/values-gl-rES/cm_strings.xml	2016-07-13 01:20:53.034700000 +0700
+++ ./Telephony_mtk/res/values-gl-rES/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -128,7 +128,6 @@
   <string name="labelCbChangePassword">Cambiar o contrasinal</string>
   <string name="cb_psw_dont_match">Os contrasinais non coinciden</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">O servizo de FDN non está dispoñíbel.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exportando contactos á tarxeta SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-gu-rIN/cm_strings.xml ./Telephony_mtk/res/values-gu-rIN/cm_strings.xml
--- ./Telephony/res/values-gu-rIN/cm_strings.xml	2016-07-13 01:20:53.034700000 +0700
+++ ./Telephony_mtk/res/values-gu-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">પાસવર્ડ સુસંગત નથી</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN અપડેટ કરવામાં આવ્યું નહીં કારણ કે નંબર ખાલી છે અથવા 20 આંકડા કરતા વધી જાય છે.</string>
-  <string name="fdn_service_unavailable">FDN સેવા ઉપલબ્ધ નથી.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">SIM કાર્ડ\u2026 પર સંપર્કો નિકાસ થઈ રહ્યા છે</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-hi/cm_strings.xml ./Telephony_mtk/res/values-hi/cm_strings.xml
--- ./Telephony/res/values-hi/cm_strings.xml	2016-07-13 01:20:53.034700000 +0700
+++ ./Telephony_mtk/res/values-hi/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">केवल जीएसएम</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">जीएसम/डब्ल्यूसीडीएमए बेहतर रहेगा</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">एफडीएन सेवा उपलब्ध नहीं है।</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">संपर्कों को सिम कार्ड में निर्यात कर रहे हैं\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-hr/cm_strings.xml ./Telephony_mtk/res/values-hr/cm_strings.xml
--- ./Telephony/res/values-hr/cm_strings.xml	2016-07-13 01:20:53.034700000 +0700
+++ ./Telephony_mtk/res/values-hr/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Lozinke se ne podudaraju</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN nije ažuriran jer je broj prazan ili prelazi 20 znamenki.</string>
-  <string name="fdn_service_unavailable">FDN usluga nije dostupna.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Izvoz kontakata na SIM karticu\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-hu/cm_strings.xml ./Telephony_mtk/res/values-hu/cm_strings.xml
--- ./Telephony/res/values-hu/cm_strings.xml	2016-07-13 01:20:53.034700000 +0700
+++ ./Telephony_mtk/res/values-hu/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">A megadott jelszavak nem egyeznek</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN nem lett frissítve, mert a szám üres, vagy meghaladja a 20 számjegyet.</string>
-  <string name="fdn_service_unavailable">FDN szolgáltatás nem elérhető.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Névjegyek exportálása a SIM kártyára\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-in/cm_strings.xml ./Telephony_mtk/res/values-in/cm_strings.xml
--- ./Telephony/res/values-in/cm_strings.xml	2016-07-13 01:20:53.038700000 +0700
+++ ./Telephony_mtk/res/values-in/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Kata sandi tidak sesuai</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN tidak diperbarui karena nomor yang kosong atau melampaui 20 digit.</string>
-  <string name="fdn_service_unavailable">Layanan FDN ini tidak tersedia.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Mengekspor kontak ke kartu SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-it/cm_strings.xml ./Telephony_mtk/res/values-it/cm_strings.xml
--- ./Telephony/res/values-it/cm_strings.xml	2016-07-13 01:20:53.038700000 +0700
+++ ./Telephony_mtk/res/values-it/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Le password non coincidono</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN non è stato aggiornato perché il numero è vuoto o supera le 20 cifre.</string>
-  <string name="fdn_service_unavailable">Servizio FDN non disponibile.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Esportazione dei contatti alla SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-iw/cm_strings.xml ./Telephony_mtk/res/values-iw/cm_strings.xml
--- ./Telephony/res/values-iw/cm_strings.xml	2016-07-13 01:20:53.038700000 +0700
+++ ./Telephony_mtk/res/values-iw/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -33,7 +33,6 @@
   <!-- My Phone Number -->
   <string name="phone_number_label">מספר הטלפון שלי</string>
   <string name="phone_number_summary">הגדר מספר טלפון למכשיר זה</string>
-  <string name="set_my_number_failed">הגדרת מספר הטלפון נכשלה</string>
   <!-- Toasts for various transient network events -->
   <!-- Toast text for Unconditional Call Forwarding enabled  -->
   <string name="call_notif_unconditionalCF">העברת שיחות לא מותנית פעילה</string>
@@ -150,7 +149,6 @@
   <string name="cb_psw_dont_match">הסיסמאות אינן תואמות</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN לא עודכן כי המספר ריק או ארוך מ-20 ספרות.</string>
-  <string name="fdn_service_unavailable">שירות FDN אינו זמין.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">מייצא אנשי קשר לכרטיס ה-SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ja/cm_strings.xml ./Telephony_mtk/res/values-ja/cm_strings.xml
--- ./Telephony/res/values-ja/cm_strings.xml	2016-07-13 01:20:53.038700000 +0700
+++ ./Telephony_mtk/res/values-ja/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -26,7 +26,7 @@
   <!-- Blacklist preferences -->
   <string name="blacklist_title">着信拒否リスト</string>
   <string name="blacklist_summary_disabled">無効</string>
-  <string name="blacklist_summary">着信拒否リストにある電話番号からの着信やメッセージを受け取らないようにする</string>
+  <string name="blacklist_summary">着信拒否リストにある電話番号からの着信やメッセージを受け取らないようになります</string>
   <!-- Sprint MWI Quirk: Phantom message wait indicator workaround -->
   <string name="mwi_notification_title">メッセージ待機インジケータ</string>
   <!-- My Phone Number -->
@@ -147,7 +147,6 @@
   <string name="cb_psw_dont_match">パスワードが一致しません</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">番号が空欄であるか20桁を超えているため、FDNは更新されませんでした。</string>
-  <string name="fdn_service_unavailable">FDNサービスは利用できません。</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">SIMカードに連絡先をエクスポート中\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-kn-rIN/cm_strings.xml ./Telephony_mtk/res/values-kn-rIN/cm_strings.xml
--- ./Telephony/res/values-kn-rIN/cm_strings.xml	2016-07-13 01:20:53.042700000 +0700
+++ ./Telephony_mtk/res/values-kn-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">ಪಾಸ್ ವರ್ಡ್ ಗಳು ಹೊಂದಾಣಿಕೆಯಾಗುತ್ತಿಲ್ಲ</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN ಅಪ್‌ಡೇಟ್‌ ಆಗಿಲ್ಲ, ಯಾಕೆಂದರೆ ನಂಬರ್ ಖಾಲಿ ಇದೆ ಅಥವಾ 20 ಅಂಕಿಗಳ ಮಿತಿ ಮೀರಿದೆ.</string>
-  <string name="fdn_service_unavailable">ಸ್ಥಿರ ಡಯಲಿಂಗ್ ಸೇವೆಯು ಲಭ್ಯವಿಲ್ಲ.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">ಸಂಪರ್ಕಗಳನ್ನು ಸಿಮ್ ಕಾರ್ಡ್‍ಗೆ ರಫ್ತು ಮಾಡುತ್ತಿದೆ\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ko/cm_strings.xml ./Telephony_mtk/res/values-ko/cm_strings.xml
--- ./Telephony/res/values-ko/cm_strings.xml	2016-07-13 01:20:53.042700000 +0700
+++ ./Telephony_mtk/res/values-ko/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">비밀번호가 일치하지 않습니다</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">번호가 비어있거나 20자리를 초과하기 때문에 FDN이 업데이트되지 않았습니다.</string>
-  <string name="fdn_service_unavailable">FDN 서비스를 사용할 수 없습니다.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">연락처를 SIM 카드로 내보내는 중\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ku/cm_strings.xml ./Telephony_mtk/res/values-ku/cm_strings.xml
--- ./Telephony/res/values-ku/cm_strings.xml	2016-07-13 01:20:53.042700000 +0700
+++ ./Telephony_mtk/res/values-ku/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -108,7 +108,6 @@
   <string name="preferred_network_mode_gsm_only_choice">تەنیا GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">GSM/WCDMA په‌سه‌ندکراو</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">خزمه‌تگوزاری FDN بەردەست نییە.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">هەناردنی پەیوەندییەکان بۆ سیمکارت\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-lb/cm_strings.xml ./Telephony_mtk/res/values-lb/cm_strings.xml
--- ./Telephony/res/values-lb/cm_strings.xml	2016-07-13 01:20:53.042700000 +0700
+++ ./Telephony_mtk/res/values-lb/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">Just GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">GSM/WCDMA preferéiert</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN-Service net disponibel.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Kontakter ginn op d\'SIM-Kaart exportéiert\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-lt/cm_strings.xml ./Telephony_mtk/res/values-lt/cm_strings.xml
--- ./Telephony/res/values-lt/cm_strings.xml	2016-07-13 01:20:53.046700000 +0700
+++ ./Telephony_mtk/res/values-lt/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">Tik GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">Pageidaujama GSM / WCDMA</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">Fiksuoto rinkimo paslaugos neteikiamos.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Eksportuojami kontaktai į SIM kortelę\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-lv/cm_strings.xml ./Telephony_mtk/res/values-lv/cm_strings.xml
--- ./Telephony/res/values-lv/cm_strings.xml	2016-07-13 01:20:53.046700000 +0700
+++ ./Telephony_mtk/res/values-lv/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -83,7 +83,6 @@
   <!-- Mobile network settings, summary for preferred network mode TD-SCDMA/LTE/CDMA/EvDo/GSM/WCDMA[CHAR LIMIT=100] -->
   <string name="preferred_network_mode_td_scdma_lte_cdma_evdo_gsm_wcdma_summary">Vēlamais tīkla režīms: TD-SCDMA/LTE/CDMA/EvDo/GSM/WCDMA</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN pakalpojums nav pieejams.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Eksportē kontaktus uz SIM karti\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ml-rIN/cm_strings.xml ./Telephony_mtk/res/values-ml-rIN/cm_strings.xml
--- ./Telephony/res/values-ml-rIN/cm_strings.xml	2016-07-13 01:20:53.050700000 +0700
+++ ./Telephony_mtk/res/values-ml-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">പാസ്സ്‌വേർഡ്‌ പൊരുത്തപ്പെടുന്നില്ല</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN wasn\'t updated because the number is empty or exceeds 20 digits.</string>
-  <string name="fdn_service_unavailable">FDN സേവനം ലഭ്യമല്ല.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">SIM കാര്‍ഡിലേക്ക് കോണ്‍ടാക്റ്റുകള്‍ എക്സ്പോർട്ട് ചെയ്യുന്നു\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-mr-rIN/cm_strings.xml ./Telephony_mtk/res/values-mr-rIN/cm_strings.xml
--- ./Telephony/res/values-mr-rIN/cm_strings.xml	2016-07-13 01:20:53.050700000 +0700
+++ ./Telephony_mtk/res/values-mr-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">पासवर्ड जुळत नाहीत</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN अद्यतन केले गेले नाही कारण नंबर रिक्त आहे किंवा 20 अंकांच्या पुढे जातो.</string>
-  <string name="fdn_service_unavailable">FDN सेवा उपलब्ध नाही.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">सिम कार्डला संपर्क निर्यात करत आहे\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-nb/cm_strings.xml ./Telephony_mtk/res/values-nb/cm_strings.xml
--- ./Telephony/res/values-nb/cm_strings.xml	2016-07-13 01:20:53.054700000 +0700
+++ ./Telephony_mtk/res/values-nb/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -17,7 +17,7 @@
 -->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
   <!-- Advanced Settings -->
-  <string name="incall_screen_settings">Skjerminnstillinger under samtaler</string>
+  <string name="incall_screen_settings">Skjerm instillinger under samtaler</string>
   <string name="show_ssn_label">Hendelsesvarsling</string>
   <string name="show_ssn_summary">Vis en melding for ulike nettverkshendelser relatert til anrop</string>
   <string name="incall_echo_cancellation">Samtale støyreduksjon</string>
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Passordene samsvarer ikke</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN ble ikke oppdatert fordi nummeret er tomt eller har fler enn 20 siffer.</string>
-  <string name="fdn_service_unavailable">FDN tjenesten er ikke tilgjengelig.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Eksporterer kontakter til SIMkort\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-nl/cm_strings.xml ./Telephony_mtk/res/values-nl/cm_strings.xml
--- ./Telephony/res/values-nl/cm_strings.xml	2016-07-13 01:20:53.054700000 +0700
+++ ./Telephony_mtk/res/values-nl/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">Wachtwoorden komen niet overeen</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN niet bijgewerkt omdat het getal leeg is of langer is dan 20 cijfers.</string>
-  <string name="fdn_service_unavailable">FDN-service niet beschikbaar.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Contacten exporteren naar simkaart\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
@@ -189,8 +188,6 @@
   <!-- Mobile network settings, COLP -->
   <string name="connected_line_identification_title">Verbindingsidentificatie</string>
   <!-- Network mode picker dialog title -->
-  <string name="choose_network_mode_title">Netwerkmodus kiezen</string>
-  <string name="choose_network_mode_system_default">Systeemstandaard</string>
   <!-- Error message displayed on SIM Network Depersonalization panel with # of retries remaining -->
   <!-- Call forward: IMS: Media tag support -->
 </resources>
diff -Naur ./Telephony/res/values-or-rIN/cm_strings.xml ./Telephony_mtk/res/values-or-rIN/cm_strings.xml
--- ./Telephony/res/values-or-rIN/cm_strings.xml	2016-07-13 01:20:53.058700000 +0700
+++ ./Telephony_mtk/res/values-or-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">ପାସୱାର୍ଡ୍ ମେଳକ ହେଲା ନାହିଁ</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">ନମ୍ବର ଖାଲି ଥିବାରୁ ବା ଏହା 20ଟି ଅଙ୍କରୁ ଅଧିକ ହୋଇଯାଉଥିବାରୁ FDN ଅଦ୍ୟତନ ହେଲା ନାହିଁ।</string>
-  <string name="fdn_service_unavailable">FDN ସେବା ଉପଲବ୍ଧ ନାହିଁ।</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">SIM କାର୍ଡ୍କୁ ସମ୍ପର୍କଗୁଡିକ ରପ୍ତାନୀ କରାଯାଉଛି\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-pl/cm_strings.xml ./Telephony_mtk/res/values-pl/cm_strings.xml
--- ./Telephony/res/values-pl/cm_strings.xml	2016-07-13 01:20:53.058700000 +0700
+++ ./Telephony_mtk/res/values-pl/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Podane hasła różnią się</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN nie był aktualizowany, ponieważ numer jest pusty lub przekracza 20 cyfr.</string>
-  <string name="fdn_service_unavailable">Usługa FDN jest niedostępna.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Eksportowanie kontaktów do karty SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-pt-rBR/cm_strings.xml ./Telephony_mtk/res/values-pt-rBR/cm_strings.xml
--- ./Telephony/res/values-pt-rBR/cm_strings.xml	2016-07-13 01:20:53.058700000 +0700
+++ ./Telephony_mtk/res/values-pt-rBR/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">As senhas não conferem</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN não foi atualizado porque o número está vazio ou excede 20 dígitos.</string>
-  <string name="fdn_service_unavailable">Serviço FDN não está disponível.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exportando contatos para o cartão SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-pt-rPT/cm_strings.xml ./Telephony_mtk/res/values-pt-rPT/cm_strings.xml
--- ./Telephony/res/values-pt-rPT/cm_strings.xml	2016-07-13 01:20:53.058700000 +0700
+++ ./Telephony_mtk/res/values-pt-rPT/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">As palavras-passe não coincidem</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN não foi atualizado porque o número está vazio ou excede 20 dígitos.</string>
-  <string name="fdn_service_unavailable">O serviço FDN não está disponível.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">A exportar contactos para o cartão SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ro/cm_strings.xml ./Telephony_mtk/res/values-ro/cm_strings.xml
--- ./Telephony/res/values-ro/cm_strings.xml	2016-07-13 01:20:53.058700000 +0700
+++ ./Telephony_mtk/res/values-ro/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -144,7 +144,6 @@
   <string name="no_call_barring">Restricționarea de apel dezactivată</string>
   <string name="cb_psw_dont_match">Parolele nu se potrivesc</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">Serviciul FDN nu este disponibil.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Se exportă contactele în cardul SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ru/cm_strings.xml ./Telephony_mtk/res/values-ru/cm_strings.xml
--- ./Telephony/res/values-ru/cm_strings.xml	2016-07-13 01:20:53.062700000 +0700
+++ ./Telephony_mtk/res/values-ru/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -33,7 +33,6 @@
   <!-- My Phone Number -->
   <string name="phone_number_label">Мой номер телефона</string>
   <string name="phone_number_summary">Задать телефонный номер для этого устройства</string>
-  <string name="set_my_number_failed">Не удалось задать номер телефона</string>
   <!-- Toasts for various transient network events -->
   <!-- Toast text for Unconditional Call Forwarding enabled  -->
   <string name="call_notif_unconditionalCF">Включена безусловная переадресация вызова</string>
@@ -150,7 +149,6 @@
   <string name="cb_psw_dont_match">Пароли не совпадают</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN не был обновлен, потому что номер не набран, или превышает 20 цифр.</string>
-  <string name="fdn_service_unavailable">Служба FDN недоступна.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Экспорт контактов на SIM-карту\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-si-rLK/cm_strings.xml ./Telephony_mtk/res/values-si-rLK/cm_strings.xml
--- ./Telephony/res/values-si-rLK/cm_strings.xml	2016-07-13 01:20:53.062700000 +0700
+++ ./Telephony_mtk/res/values-si-rLK/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -83,7 +83,6 @@
   <!-- Mobile network settings, summary for preferred network mode TD-SCDMA/LTE/CDMA/EvDo/GSM/WCDMA[CHAR LIMIT=100] -->
   <string name="preferred_network_mode_td_scdma_lte_cdma_evdo_gsm_wcdma_summary">වඩා කැමති ජාල ප්‍රකාරය: TD-SCDMA/LTE/CDMA/EvDo/GSM/WCDMA</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN සේවාව ලබා ගත නොහැක.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">සම්බන්ධතා සිම් කාඩ්පතට නිර්යාත කරමින්\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-sk/cm_strings.xml ./Telephony_mtk/res/values-sk/cm_strings.xml
--- ./Telephony/res/values-sk/cm_strings.xml	2016-07-13 01:20:53.062700000 +0700
+++ ./Telephony_mtk/res/values-sk/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -110,7 +110,6 @@
   <string name="preferred_network_mode_gsm_only_choice">Iba GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">Preferované GSM/WCDMA</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">Služba FDN nie je k dispozícii.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Export kontaktov na kartu SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-sl/cm_strings.xml ./Telephony_mtk/res/values-sl/cm_strings.xml
--- ./Telephony/res/values-sl/cm_strings.xml	2016-07-13 01:20:53.062700000 +0700
+++ ./Telephony_mtk/res/values-sl/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Gesli se ne ujemata</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN ni bil posodobljen, ker je število prazno ali presega 20 številk.</string>
-  <string name="fdn_service_unavailable">Storitev FDN ni na voljo.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Izvažanje stikov na kartico SIM \u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-sr/cm_strings.xml ./Telephony_mtk/res/values-sr/cm_strings.xml
--- ./Telephony/res/values-sr/cm_strings.xml	2016-07-13 01:20:53.062700000 +0700
+++ ./Telephony_mtk/res/values-sr/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">Лозинке се не подударају</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN није ажуриран јер је број празан или прелази 20 цифара.</string>
-  <string name="fdn_service_unavailable">FDN услуга није доступна.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Извоз контаката на SIM картицу\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-sv/cm_strings.xml ./Telephony_mtk/res/values-sv/cm_strings.xml
--- ./Telephony/res/values-sv/cm_strings.xml	2016-07-13 01:20:53.066700000 +0700
+++ ./Telephony_mtk/res/values-sv/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">Lösenorden matchar inte</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN uppdaterades inte eftersom numret är tomt eller överskrider 20 siffror.</string>
-  <string name="fdn_service_unavailable">FDN-tjänst är ej tillgänglig.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Exporterar kontakter till SIM-kort\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ta-rIN/cm_strings.xml ./Telephony_mtk/res/values-ta-rIN/cm_strings.xml
--- ./Telephony/res/values-ta-rIN/cm_strings.xml	2016-07-13 01:20:53.066700000 +0700
+++ ./Telephony_mtk/res/values-ta-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">கடவுச்சொற்கள் பொருந்தவில்லை</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN புதுப்பிக்கப்படவில்லை ஏனென்றால் எண் வெறுமையாக அல்லது 20 இலக்கங்களுக்கு மேல் உள்ளது.</string>
-  <string name="fdn_service_unavailable">FDN சேவை கிடைக்கவில்லை</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">SIM கார்டுக்கு தொடர்புகளை ஏற்றுமதிசெய்\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-te-rIN/cm_strings.xml ./Telephony_mtk/res/values-te-rIN/cm_strings.xml
--- ./Telephony/res/values-te-rIN/cm_strings.xml	2016-07-13 01:20:53.066700000 +0700
+++ ./Telephony_mtk/res/values-te-rIN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">పాస్వర్డులు సరిపోలలేదు</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">నంబరు ఖాళీగా ఉండడం వలన లేదా 20 అంకెలు దాటడం వలన FDN నవీకరణ కాలేదు.</string>
-  <string name="fdn_service_unavailable">FDN సేవ అందుబాటులో లేదు.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">పరిచయాలు SIM కార్డుకు ఎగుమతి చేయబడుతున్నాయి\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-th/cm_strings.xml ./Telephony_mtk/res/values-th/cm_strings.xml
--- ./Telephony/res/values-th/cm_strings.xml	2016-07-13 01:20:53.066700000 +0700
+++ ./Telephony_mtk/res/values-th/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">รหัสผ่านไม่ตรงกัน</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN ไม่ถูกเปลี่ยนเนื่องจากหมายเลขว่างเปล่าหรือเกิน 20 ตัว</string>
-  <string name="fdn_service_unavailable">ไม่มีบริการ FDN</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">กำลังส่งออกรายชื่อติดต่อไปที่ซิม\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-tr/cm_strings.xml ./Telephony_mtk/res/values-tr/cm_strings.xml
--- ./Telephony/res/values-tr/cm_strings.xml	2016-07-13 01:20:53.066700000 +0700
+++ ./Telephony_mtk/res/values-tr/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Şifreler eşleşmiyor</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN güncellenmedi çünkü numara girilmedi ya da 20 basamağı aşıyor.</string>
-  <string name="fdn_service_unavailable">FDN hizmeti kullanılabilir değil.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Kişiler SIM karta aktarılıyor\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-ug/cm_strings.xml ./Telephony_mtk/res/values-ug/cm_strings.xml
--- ./Telephony/res/values-ug/cm_strings.xml	2016-07-13 01:20:53.070700000 +0700
+++ ./Telephony_mtk/res/values-ug/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">پارول ئۇدۇللاشمىدى</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">نومۇر قورۇق ياكى 20 خاندىن ئارتۇق، FDN نى يېڭىليالمىدى.</string>
-  <string name="fdn_service_unavailable">FDN مۇلازىمىتىنى ئىشلەتكىلى بولمايدۇ.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">ئالاقەداشلارنى SIM كارتىغا چىقىرىۋاتىدۇ\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-uk/cm_strings.xml ./Telephony_mtk/res/values-uk/cm_strings.xml
--- ./Telephony/res/values-uk/cm_strings.xml	2016-07-13 01:20:53.070700000 +0700
+++ ./Telephony_mtk/res/values-uk/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -148,7 +148,6 @@
   <string name="cb_psw_dont_match">Паролі не співпадають</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN не було оновлено оскільки номер пустий, або перевищує 20 цифр.</string>
-  <string name="fdn_service_unavailable">Служба FDN недоступна.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Експортування контактів на SIM-картку\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-vi/cm_strings.xml ./Telephony_mtk/res/values-vi/cm_strings.xml
--- ./Telephony/res/values-vi/cm_strings.xml	2016-07-13 01:20:53.070700000 +0700
+++ ./Telephony_mtk/res/values-vi/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -149,7 +149,6 @@
   <string name="cb_psw_dont_match">Mật khẩu không khớp</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN không được cập nhật vì số rỗng hoặc vượt quá 20 chữ số.</string>
-  <string name="fdn_service_unavailable">Dịch vụ FDN không khả dụng.</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">Xuất danh bạ sang thẻ SIM\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-zh-rCN/cm_strings.xml ./Telephony_mtk/res/values-zh-rCN/cm_strings.xml
--- ./Telephony/res/values-zh-rCN/cm_strings.xml	2016-07-13 01:20:53.070700000 +0700
+++ ./Telephony_mtk/res/values-zh-rCN/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -150,7 +150,6 @@
   <string name="cb_psw_dont_match">密码不匹配</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">号码为空或超过 20 位数字，未能更新 FDN。</string>
-  <string name="fdn_service_unavailable">FDN 服务不可用。</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">正在将联系人导出至 SIM 卡\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-zh-rHK/cm_strings.xml ./Telephony_mtk/res/values-zh-rHK/cm_strings.xml
--- ./Telephony/res/values-zh-rHK/cm_strings.xml	2016-07-13 01:20:53.070700000 +0700
+++ ./Telephony_mtk/res/values-zh-rHK/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -100,7 +100,6 @@
   <string name="preferred_network_mode_gsm_only_choice">僅 GSM</string>
   <string name="preferred_network_mode_gsm_wcdma_preferred_choice">首選 GSM/WCDMA</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
-  <string name="fdn_service_unavailable">FDN 服務無法使用。</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">匯出聯絡人至 SIM 卡\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/res/values-zh-rTW/cm_strings.xml ./Telephony_mtk/res/values-zh-rTW/cm_strings.xml
--- ./Telephony/res/values-zh-rTW/cm_strings.xml	2016-07-13 01:20:53.074700000 +0700
+++ ./Telephony_mtk/res/values-zh-rTW/cm_strings.xml	2016-07-03 12:41:26.000000000 +0700
@@ -132,7 +132,6 @@
   <string name="cb_psw_dont_match">密碼不符</string>
   <!-- FDN settings: error message displayed in a popup (toast) -->
   <string name="fdn_invalid_number_cm">FDN 尚未更新，因為數字為空或超過 20 位。</string>
-  <string name="fdn_service_unavailable">FDN 服務無法使用。</string>
   <!-- Title of the activity shown for Exporting contacts to SIM.  -->
   <string name="exportContacts">匯出電話通訊錄到 SIM 卡\u2026</string>
   <!-- Title of the List shown for SIM Contacts Management Activity.  -->
diff -Naur ./Telephony/src/com/android/phone/PhoneGlobals.java ./Telephony_mtk/src/com/android/phone/PhoneGlobals.java
--- ./Telephony/src/com/android/phone/PhoneGlobals.java	2016-07-13 01:20:53.098700000 +0700
+++ ./Telephony_mtk/src/com/android/phone/PhoneGlobals.java	2016-07-03 12:41:26.000000000 +0700
@@ -65,6 +65,8 @@
 import com.android.server.sip.SipService;
 import com.android.services.telephony.activation.SimActivationManager;
 
+import com.mediatek.phone.PhoneInterfaceManagerEx;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -210,6 +212,11 @@
 
 
 
+    // MTK
+    PhoneInterfaceManagerEx phoneMgrEx;
+
+
+
     /**
      * Set the restore mute state flag. Used when we are setting the mute state
      * OUTSIDE of user interaction {@link PhoneUtils#startNewCall(Phone)}
@@ -376,6 +383,7 @@
             callStateMonitor = new CallStateMonitor(mCM);
 
             phoneMgr = PhoneInterfaceManager.init(this, PhoneFactory.getDefaultPhone());
+            phoneMgrEx = PhoneInterfaceManagerEx.init(this, PhoneFactory.getDefaultPhone());  // MTK
 
             configLoader = CarrierConfigLoader.init(this);
 
diff -Naur ./Telephony/src/com/android/services/telephony/TelephonyConnectionService.java ./Telephony_mtk/src/com/android/services/telephony/TelephonyConnectionService.java
--- ./Telephony/src/com/android/services/telephony/TelephonyConnectionService.java	2016-07-13 01:20:53.110700000 +0700
+++ ./Telephony_mtk/src/com/android/services/telephony/TelephonyConnectionService.java	2016-07-03 12:41:26.000000000 +0700
@@ -62,8 +62,6 @@
  * Service for making GSM and CDMA connections.
  */
 public class TelephonyConnectionService extends ConnectionService {
-    private static final int INVALID = -1;
-    private static final int PRIMARY_STACK_MODEMID = 0;
 
     // If configured, reject attempts to dial numbers matching this pattern.
     private static final Pattern CDMA_ACTIVATION_CODE_REGEX_PATTERN =
@@ -667,79 +665,41 @@
 
     private Phone getFirstPhoneForEmergencyCall() {
         Phone selectPhone = null;
-        final TelephonyManager tm = TelephonyManager.getDefault();
-        final SubscriptionController subscriptionController = SubscriptionController.getInstance();
-        for (int i = 0; i < tm.getSimCount(); i++) {
-            int[] subIds = subscriptionController.getSubIdUsingSlotId(i);
+        for (int i = 0; i < TelephonyManager.getDefault().getSimCount(); i++) {
+            int[] subIds = SubscriptionController.getInstance().getSubIdUsingSlotId(i);
             if (subIds.length == 0)
                 continue;
 
-            int phoneId = subscriptionController.getPhoneId(subIds[0]);
+            int phoneId = SubscriptionController.getInstance().getPhoneId(subIds[0]);
             Phone phone = PhoneFactory.getPhone(phoneId);
             if (phone == null)
                 continue;
 
-            if (ServiceState.STATE_IN_SERVICE == phone.getServiceState().getState() ||
-                    phone.getServiceState().isEmergencyOnly()) {
+            if (ServiceState.STATE_IN_SERVICE == phone.getServiceState().getState()) {
                 // the slot is radio on & state is in service
-                Log.i(this, "pickBestPhoneForEmergencyCall, " +
-                        "radio on & in service or in emergency mode, slotId:" + i);
+                Log.d(this, "pickBestPhoneForEmergencyCall, radio on & in service, slotId:" + i);
                 return phone;
             } else if (ServiceState.STATE_POWER_OFF != phone.getServiceState().getState()) {
-                // the slot is radio on & with SIM card inserted in a ready state,
-                // with an active sub
-                if (tm.hasIccCard(i) && tm.getSimState(i) == TelephonyManager.SIM_STATE_READY
-                        && subscriptionController.getSubState(subIds[i]) == SubscriptionManager.ACTIVE) {
-                    Log.i(this, "pickBestPhoneForEmergencyCall," +
-                            "radio on and SIM ready, slotId:" + i);
+                // the slot is radio on & with SIM card inserted.
+                if (TelephonyManager.getDefault().hasIccCard(i)) {
+                    Log.d(this, "pickBestPhoneForEmergencyCall," +
+                            "radio on and SIM card inserted, slotId:" + i);
+                    selectPhone = phone;
+                } else if (selectPhone == null) {
+                    Log.d(this, "pickBestPhoneForEmergencyCall, radio on, slotId:" + i);
                     selectPhone = phone;
                 }
             }
         }
 
         if (selectPhone == null) {
-            Log.i(this, "pickBestPhoneForEmergencyCall, return primary stack phone");
-            selectPhone = PhoneFactory.getPhone(getPrimaryStackPhoneId());
+            Log.d(this, "pickBestPhoneForEmergencyCall, return phone 0");
+            selectPhone = PhoneFactory.getPhone(0);
         }
 
         return selectPhone;
     }
 
-    private int getPrimaryStackPhoneId() {
-        String modemUuId = null;
-        Phone phone = null;
-        int primayStackPhoneId = INVALID;
-
-        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
-
-            phone = PhoneFactory.getPhone(i);
-            if (phone == null) continue;
-
-            Log.i(this, "Logical Modem id: " + phone.getModemUuId() + " phoneId: " + i);
-            modemUuId = phone.getModemUuId();
-            if ((modemUuId == null) || (modemUuId.length() <= 0) ||
-                    modemUuId.isEmpty()) {
-                continue;
-            }
-            // Select the phone id based on modemUuid
-            // if modemUuid is 0 for any phone instance, primary stack is mapped
-            // to it so return the phone id as the primary stack phone id.
-            if (Integer.parseInt(modemUuId) == PRIMARY_STACK_MODEMID) {
-                primayStackPhoneId = i;
-                Log.i(this, "Primay Stack phone id: " + primayStackPhoneId + " selected");
-                break;
-            }
-        }
-
-        // never return INVALID
-        if( primayStackPhoneId == INVALID){
-            Log.i(this, "Returning default phone id");
-            primayStackPhoneId = 0;
-        }
-
-        return primayStackPhoneId;
-    }
-
     /**
      * Determines if the connection should allow mute.
      *
diff -Naur ./Telephony/src/com/mediatek/phone/PhoneFeatureConstants.java ./Telephony_mtk/src/com/mediatek/phone/PhoneFeatureConstants.java
--- ./Telephony/src/com/mediatek/phone/PhoneFeatureConstants.java	1970-01-01 07:00:00.000000000 +0700
+++ ./Telephony_mtk/src/com/mediatek/phone/PhoneFeatureConstants.java	2016-07-03 12:41:26.000000000 +0700
@@ -0,0 +1,151 @@
+/*
+* Copyright (C) 2011-2014 Mediatek.inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.mediatek.phone;
+
+import android.content.Context;
+import android.media.AudioManager;
+import android.os.SystemProperties;
+import android.util.Log;
+
+import com.android.phone.PhoneGlobals;
+
+public class PhoneFeatureConstants {
+
+    public static final class FeatureOption {
+        private static final String TAG = "FeatureOption";
+        private static final String MTK_DUAL_MIC_SUPPORT = "MTK_DUAL_MIC_SUPPORT";
+        private static final String MTK_DUAL_MIC_SUPPORT_on = "MTK_DUAL_MIC_SUPPORT=true";
+        private final static String ONE = "1";
+        // C2K 5M (CLLWG)
+        private final static String C2K_5M = "CLLWG";
+
+        // C2k 3M (CWG)
+        private final static String C2K_3M = "CWG";
+
+        // C2k OM 4M (CLLG)
+        private final static String C2K_4M = "CLLG";
+
+        public static boolean isMtkDualMicSupport() {
+            String state = null;
+            AudioManager audioManager = (AudioManager)
+                    PhoneGlobals.getInstance().getSystemService(Context.AUDIO_SERVICE);
+            if (audioManager != null) {
+                state = audioManager.getParameters(MTK_DUAL_MIC_SUPPORT);
+                Log.d(state, "isMtkDualMicSupport(): state: " + state);
+                if (state.equalsIgnoreCase(MTK_DUAL_MIC_SUPPORT_on)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        public static boolean isMtkFemtoCellSupport() {
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk_femto_cell_support")) ? true : false;
+            Log.d(TAG, "isMtkFemtoCellSupport(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtk3gDongleSupport() {
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk_3gdongle_support")) ? true : false;
+            Log.d(TAG, "isMtk3gDongleSupport()" + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtkLteSupport() {
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk_lte_support")) ? true : false;
+            Log.d(TAG, "isMtkLteSupport(): " + isSupport);
+            return isSupport;
+        }
+
+        /**
+         * ro.mtk_c2k_om_nw_sel_type value:
+         * 1 : Foreign (India)
+         * 0 : Home
+         * @return
+         */
+        public static boolean isLoadForHome() {
+            boolean isSupport = 1 == SystemProperties.getInt(
+                    "ro.mtk_c2k_om_nw_sel_type", 0) ? false : true;
+            Log.d(TAG, "isLoadForHome(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtkC2k5MSupport() {
+            boolean isSupport = C2K_5M.equalsIgnoreCase(
+                    SystemProperties.get("ro.mtk.c2k.om.mode")) ? true : false;
+            Log.d(TAG, "isMtkC2k5M(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtkC2k4MSupport() {
+            boolean isSupport = C2K_4M.equalsIgnoreCase(
+                    SystemProperties.get("ro.mtk.c2k.om.mode")) ? true : false;
+            Log.d(TAG, "isMtkC2k4M(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtkC2k3MSupport() {
+            boolean isSupport = C2K_3M.equalsIgnoreCase(
+                    SystemProperties.get("ro.mtk.c2k.om.mode")) ? true : false;
+            Log.d(TAG, "isMtkC2k3M(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtkSvlteSupport() {
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk_svlte_support")) ? true : false;
+            Log.d(TAG, "isMtkSvlteSupport(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtkSrlteSupport() {
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk_srlte_support")) ? true : false;
+            Log.d(TAG, "isMtkSrlteSupport(): " + isSupport);
+            return isSupport;
+        }
+
+        /**
+         * add for svlte solution2 selection.
+         * solution2: true
+         * solution1.5: false
+         * @return
+         */
+        public static boolean isMtkSvlteSolutionSupport(){
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk.c2k.slot2.support")) ? true : false;
+            Log.d(TAG, "isMtkSvlteSupport(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMtkCtaSet() {
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk_cta_set")) ? true : false;
+            Log.d(TAG, "isMtkCtaSet(): " + isSupport);
+            return isSupport;
+        }
+
+        public static boolean isMTKA1Support() {
+            boolean isSupport = ONE.equals(
+                    SystemProperties.get("ro.mtk_a1_feature")) ? true : false;
+            Log.d(TAG, "isMTKA1Support(): " + isSupport);
+            return isSupport;
+        }
+    }
+}
diff -Naur ./Telephony/src/com/mediatek/phone/PhoneInterfaceManagerEx.java ./Telephony_mtk/src/com/mediatek/phone/PhoneInterfaceManagerEx.java
--- ./Telephony/src/com/mediatek/phone/PhoneInterfaceManagerEx.java	1970-01-01 07:00:00.000000000 +0700
+++ ./Telephony_mtk/src/com/mediatek/phone/PhoneInterfaceManagerEx.java	2016-07-03 12:41:26.000000000 +0700
@@ -0,0 +1,2704 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.phone;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager.NameNotFoundException;
+
+import android.net.LinkProperties;
+
+import android.os.AsyncResult;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.util.Log;
+import android.telephony.RadioAccessFamily;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+
+
+import com.android.phone.PhoneGlobals;
+
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.IccCard;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.MccTable;
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneProxy;
+import com.android.internal.telephony.ProxyController;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.TelephonyProperties;
+import com.android.internal.telephony.uicc.IccIoResult;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.IccUtils;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccController;
+
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.ITelephonyEx;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+import com.android.internal.telephony.dataconnection.DcTrackerBase;
+
+import com.android.internal.telephony.dataconnection.DcFailCause;
+
+import com.mediatek.internal.telephony.BtSimapOperResponse;
+import java.util.ArrayList;
+
+
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteRatController;
+
+// import com.mediatek.telephony.ExternalSimManager;
+import com.mediatek.telephony.TelephonyManagerEx;
+
+/**
+ * Implementation of the ITelephony interface.
+ */
+public class PhoneInterfaceManagerEx extends ITelephonyEx.Stub {
+
+    private static final String LOG_TAG = "PhoneInterfaceManagerEx";
+    private static final boolean DBG = true;
+
+    /** The singleton instance. */
+    private static PhoneInterfaceManagerEx sInstance;
+
+    PhoneGlobals mApp;
+    Phone mPhone;
+
+    MainThreadHandler mMainThreadHandler;
+
+    // Query SIM phonebook Adn stroage info thread
+    private QueryAdnInfoThread mAdnInfoThread = null;
+
+    // SIM authenthication thread
+    private SimAuth mSimAuthThread = null;
+
+    /* SMS Center Address start*/
+    private static final int CMD_HANDLE_GET_SCA = 11;
+    private static final int CMD_GET_SCA_DONE = 12;
+    private static final int CMD_HANDLE_SET_SCA = 13;
+    private static final int CMD_SET_SCA_DONE = 14;
+    /* SMS Center Address end*/
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    private static final int CMD_SET_LTE_ACCESS_STRATUM_STATE =35;
+    private static final int EVENT_SET_LTE_ACCESS_STRATUM_STATE_DONE =36;
+    private static final int CMD_SET_LTE_UPLINK_DATA_TRANSFER_STATE=37;
+    private static final int EVENT_SET_LTE_UPLINK_DATA_TRANSFER_STATE_DONE =38;
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    private static final String[] PROPERTY_RIL_TEST_SIM = {
+        "gsm.sim.ril.testsim",
+        "gsm.sim.ril.testsim.2",
+        "gsm.sim.ril.testsim.3",
+        "gsm.sim.ril.testsim.4",
+    };
+
+    /**
+     * Initialize the singleton PhoneInterfaceManagerEx instance.
+     * This is only done once, at startup, from PhoneGlobals.onCreate().
+     */
+    /* package */
+    public static PhoneInterfaceManagerEx init(PhoneGlobals app, Phone phone) {
+        synchronized (PhoneInterfaceManagerEx.class) {
+            if (sInstance == null) {
+                sInstance = new PhoneInterfaceManagerEx(app, phone);
+            } else {
+                Log.wtf(LOG_TAG, "init() called multiple times!  sInstance = " + sInstance);
+            }
+            return sInstance;
+        }
+    }
+
+    /** Private constructor; @see init() */
+    private PhoneInterfaceManagerEx(PhoneGlobals app, Phone phone) {
+        mApp = app;
+        mPhone = phone;
+        mMainThreadHandler = new MainThreadHandler();
+        publish();
+    }
+
+    private void publish() {
+        if (DBG) log("publish: " + this);
+
+        ServiceManager.addService("phoneEx", this);
+
+        // MTK TODO
+        /*
+        if (SystemProperties.getInt("ro.mtk_external_sim_support", 0) == 1) {
+            ExternalSimManager.getDefault(mPhone.getContext());
+        }
+        */
+    }
+
+    private static void log(String msg) {
+        Log.d(LOG_TAG, "[PhoneIntfMgrEx] " + msg);
+    }
+
+    private static void loge(String msg) {
+        Log.e(LOG_TAG, "[PhoneIntfMgrEx] " + msg);
+    }
+
+    /**
+     * A request object for use with {@link MainThreadHandler}. Requesters should wait() on the
+     * request after sending. The main thread will notify the request when it is complete.
+     */
+    private static final class MainThreadRequest {
+        /** The argument to use for the request */
+        public Object argument;
+        /** The result of the request that is run on the main thread */
+        public Object result;
+        public Object argument2;
+
+        public MainThreadRequest(Object argument) {
+            this.argument = argument;
+        }
+
+        public MainThreadRequest(Object argument, Object argument2) {
+            this.argument = argument;
+            this.argument2 = argument2;
+        }
+    }
+
+    /**
+     * A handler that processes messages on the main thread in the phone process. Since many
+     * of the Phone calls are not thread safe this is needed to shuttle the requests from the
+     * inbound binder threads to the main thread in the phone process.  The Binder thread
+     * may provide a {@link MainThreadRequest} object in the msg.obj field that they are waiting
+     * on, which will be notified when the operation completes and will contain the result of the
+     * request.
+     *
+     * <p>If a MainThreadRequest object is provided in the msg.obj field,
+     * note that request.result must be set to something non-null for the calling thread to
+     * unblock.
+     */
+    private final class MainThreadHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            MainThreadRequest request;
+            Message onCompleted;
+            AsyncResult ar;
+            int subId;
+            int phoneId;
+
+            switch (msg.what) {
+                case CMD_HANDLE_GET_SCA:
+                    request = (MainThreadRequest) msg.obj;
+                    onCompleted = obtainMessage(CMD_GET_SCA_DONE, request);
+
+                    if (request.argument == null) {
+                        // no argument, ignore
+                        log("[sca get sc address but no argument");
+                    } else {
+                        subId = (Integer) request.argument;
+                        getPhone(subId).getSmscAddress(onCompleted);
+                    }
+                    break;
+
+                case CMD_GET_SCA_DONE:
+                    ar = (AsyncResult) msg.obj;
+                    request = (MainThreadRequest) ar.userObj;
+
+                    Bundle result = new Bundle();
+                    if (ar.exception == null && ar.result != null) {
+                        log("[sca get result" + ar.result);
+                        result.putByte(TelephonyManagerEx.GET_SC_ADDRESS_KEY_RESULT,
+                                TelephonyManagerEx.ERROR_CODE_NO_ERROR);
+                        result.putCharSequence(TelephonyManagerEx.GET_SC_ADDRESS_KEY_ADDRESS,
+                                (String) ar.result);
+                    } else {
+                        log("[sca Fail to get sc address");
+                        // Currently modem will return generic error without specific error cause,
+                        // So we treat all exception as the same error cause.
+                        result.putByte(TelephonyManagerEx.GET_SC_ADDRESS_KEY_RESULT,
+                                TelephonyManagerEx.ERROR_CODE_GENERIC_ERROR);
+                        result.putCharSequence(TelephonyManagerEx.GET_SC_ADDRESS_KEY_ADDRESS, "");
+                    }
+                    request.result = result;
+
+                    synchronized (request) {
+                        log("[sca notify sleep thread");
+                        request.notifyAll();
+                    }
+                    break;
+
+                case CMD_HANDLE_SET_SCA:
+                    request = (MainThreadRequest) msg.obj;
+                    onCompleted = obtainMessage(CMD_SET_SCA_DONE, request);
+
+                    ScAddress sca = (ScAddress) request.argument;
+                    if (sca.mSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+                        // invalid subscription ignore
+                        log("[sca invalid subscription");
+                    } else {
+                        getPhone(sca.mSubId).setSmscAddress(sca.mAddress, onCompleted);
+                    }
+                    break;
+
+                case CMD_SET_SCA_DONE:
+                    ar = (AsyncResult) msg.obj;
+                    request = (MainThreadRequest) ar.userObj;
+                    if (ar.exception != null) {
+                        Log.d(LOG_TAG, "[sca Fail: set sc address");
+                        request.result = new Boolean(false);
+                    } else {
+                        Log.d(LOG_TAG, "[sca Done: set sc address");
+                        request.result = new Boolean(true);
+                    }
+
+                    synchronized (request) {
+                        request.notifyAll();
+                    }
+                    break;
+
+                // M: [LTE][Low Power][UL traffic shaping] Start
+                case CMD_SET_LTE_ACCESS_STRATUM_STATE:
+                    request = (MainThreadRequest) msg.obj;
+                    boolean enabled = ((Boolean) request.argument).booleanValue();
+                    phoneId = ((Integer) request.argument2).intValue();
+                    if (DBG) {
+                        log("CMD_SET_LTE_ACCESS_STRATUM_STATE: enabled " + enabled
+                                + "phoneId " + phoneId);
+                    }
+                    mPhone = PhoneFactory.getPhone(phoneId);
+                    if (mPhone == null) {
+                        loge("setLteAccessStratumReport: No MainPhone");
+                        request.result = new Boolean(false);
+                        synchronized (request) {
+                            request.notifyAll();
+                        }
+                    } else {
+                        // MTK TODO
+                        /*
+                        PhoneBase phoneBase = (PhoneBase)(((PhoneProxy)mPhone).getActivePhone());
+                        DcTrackerBase dcTracker = phoneBase.mDcTracker;
+                        onCompleted = obtainMessage(EVENT_SET_LTE_ACCESS_STRATUM_STATE_DONE,
+                                request);
+                        dcTracker.onSetLteAccessStratumReport((Boolean) enabled, onCompleted);
+                        */
+                    }
+                    break;
+
+                case EVENT_SET_LTE_ACCESS_STRATUM_STATE_DONE:
+                    if (DBG) log("EVENT_SET_LTE_ACCESS_STRATUM_STATE_DONE");
+                    handleNullReturnEvent(msg, "setLteAccessStratumReport");
+                    break;
+
+                case CMD_SET_LTE_UPLINK_DATA_TRANSFER_STATE:
+                    request = (MainThreadRequest) msg.obj;
+                    int state = ((Integer) request.argument).intValue();
+                    phoneId = ((Integer) request.argument2).intValue();
+                    if (DBG) {
+                        log("CMD_SET_LTE_UPLINK_DATA_TRANSFER_STATE: state " + state
+                                + "phoneId " + phoneId);
+                    }
+                    mPhone = PhoneFactory.getPhone(phoneId);
+                    if (mPhone == null) {
+                        loge("setLteUplinkDataTransfer: No MainPhone");
+                        request.result = new Boolean(false);
+                        synchronized (request) {
+                            request.notifyAll();
+                        }
+                    } else {
+                        // MTK TODO
+                        /*
+                        PhoneBase phoneBase = (PhoneBase)(((PhoneProxy)mPhone).getActivePhone());
+                        DcTrackerBase dcTracker = phoneBase.mDcTracker;
+                        onCompleted = obtainMessage(EVENT_SET_LTE_UPLINK_DATA_TRANSFER_STATE_DONE,
+                                request);
+                        dcTracker.onSetLteUplinkDataTransfer((Integer) state, onCompleted);
+                        */
+                    }
+                    break;
+
+                case EVENT_SET_LTE_UPLINK_DATA_TRANSFER_STATE_DONE:
+                    if (DBG) log("EVENT_SET_LTE_UPLINK_DATA_TRANSFER_STATE_DONE");
+                    handleNullReturnEvent(msg, "setLteUplinkDataTransfer");
+                    break;
+                // M: [LTE][Low Power][UL traffic shaping] End
+
+                default:
+                    break;
+            }
+        }
+
+        private void handleNullReturnEvent(Message msg, String command) {
+            AsyncResult ar = (AsyncResult) msg.obj;
+            MainThreadRequest request = (MainThreadRequest) ar.userObj;
+            if (ar.exception == null) {
+                request.result = new Boolean(true);
+            } else {
+                request.result = new Boolean(false);
+                if (ar.exception instanceof CommandException) {
+                    loge(command + ": CommandException: " + ar.exception);
+                } else {
+                    loge(command + ": Unknown exception");
+                }
+            }
+            synchronized (request) {
+                request.notifyAll();
+            }
+        }
+    }
+
+    /**
+     * Posts the specified command to be executed on the main thread,
+     * waits for the request to complete, and returns the result.
+     * @see sendRequestAsync
+     */
+    private Object sendRequest(int command, Object argument) {
+        if (Looper.myLooper() == mMainThreadHandler.getLooper()) {
+            throw new RuntimeException("This method will deadlock if called from the main thread.");
+        }
+
+        MainThreadRequest request = new MainThreadRequest(argument);
+        Message msg = mMainThreadHandler.obtainMessage(command, request);
+        msg.sendToTarget();
+
+        // Wait for the request to complete
+        synchronized (request) {
+            while (request.result == null) {
+                try {
+                    request.wait();
+                } catch (InterruptedException e) {
+                    // Do nothing, go back and wait until the request is complete
+                }
+            }
+        }
+        return request.result;
+    }
+
+   /**
+     * Posts the specified command to be executed on the main thread,
+     * waits for the request to complete, and returns the result.
+     * @see #sendRequestAsync
+     */
+    private Object sendRequest(int command, Object argument, Object argument2) {
+        if (Looper.myLooper() == mMainThreadHandler.getLooper()) {
+            throw new RuntimeException("This method will deadlock if called from the main thread.");
+        }
+
+        MainThreadRequest request = new MainThreadRequest(argument, argument2);
+        Message msg = mMainThreadHandler.obtainMessage(command, request);
+        msg.sendToTarget();
+
+        // Wait for the request to complete
+        synchronized (request) {
+            while (request.result == null) {
+                try {
+                    request.wait();
+                } catch (InterruptedException e) {
+                    // Do nothing, go back and wait until the request is complete
+                }
+            }
+        }
+        return request.result;
+    }
+
+    private static Phone getPhone(int subId) {
+        // FIXME: getPhone by subId
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        return PhoneFactory.getPhone(
+                ((phoneId < 0) ? SubscriptionManager.DEFAULT_PHONE_INDEX : phoneId));
+    }
+
+    private static Phone getPhoneUsingPhoneId(int phoneId) {
+        return PhoneFactory.getPhone(phoneId);
+    }
+
+    private int getSubIdBySlot(int slot) {
+        int [] subIds = SubscriptionManager.getSubId(slot);
+        int subId = ((subIds == null) ? SubscriptionManager.getDefaultSubId() : subIds[0]);
+        if (DBG) log("getSubIdBySlot, simId " + slot + "subId " + subId);
+        return subId;
+    }
+
+    private class UnlockSim extends Thread {
+
+        /* Query network lock start */
+
+        // Verify network lock result.
+        public static final int VERIFY_RESULT_PASS = 0;
+        public static final int VERIFY_INCORRECT_PASSWORD = 1;
+        public static final int VERIFY_RESULT_EXCEPTION = 2;
+
+        // Total network lock count.
+        public static final int NETWORK_LOCK_TOTAL_COUNT = 5;
+        public static final String QUERY_SIMME_LOCK_RESULT = "com.mediatek.phone.QUERY_SIMME_LOCK_RESULT";
+        public static final String SIMME_LOCK_LEFT_COUNT = "com.mediatek.phone.SIMME_LOCK_LEFT_COUNT";
+
+        /* Query network lock end */
+
+
+        private final IccCard mSimCard;
+
+        private boolean mDone = false;
+        private boolean mResult = false;
+
+        // For replies from SimCard interface
+        private Handler mHandler;
+
+        private static final int QUERY_NETWORK_STATUS_COMPLETE = 100;
+        private static final int SET_NETWORK_LOCK_COMPLETE = 101;
+
+        private int mVerifyResult = -1;
+        private int mSIMMELockRetryCount = -1;
+
+        public UnlockSim(IccCard simCard) {
+            mSimCard = simCard;
+        }
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            synchronized (UnlockSim.this) {
+                mHandler = new Handler() {
+                    @Override
+                    public void handleMessage(Message msg) {
+                        AsyncResult ar = (AsyncResult) msg.obj;
+                        switch (msg.what) {
+                            case QUERY_NETWORK_STATUS_COMPLETE:
+                                synchronized (UnlockSim.this) {
+                                    int [] LockState = (int []) ar.result;
+                                    if (ar.exception != null) { //Query exception occurs
+                                        log("Query network lock fail");
+                                        mResult = false;
+                                        mDone = true;
+                                    } else {
+                                        mSIMMELockRetryCount = LockState[2];
+                                        log("[SIMQUERY] Category = " + LockState[0]
+                                            + " ,Network status =" + LockState[1]
+                                            + " ,Retry count = " + LockState[2]);
+
+                                        mDone = true;
+                                        mResult = true;
+                                        UnlockSim.this.notifyAll();
+                                    }
+                                }
+                                break;
+                            case SET_NETWORK_LOCK_COMPLETE:
+                                log("SUPPLY_NETWORK_LOCK_COMPLETE");
+                                synchronized (UnlockSim.this) {
+                                    if ((ar.exception != null) &&
+                                           (ar.exception instanceof CommandException)) {
+                                        log("ar.exception " + ar.exception);
+                                        if (((CommandException) ar.exception).getCommandError()
+                                            == CommandException.Error.PASSWORD_INCORRECT) {
+                                            mVerifyResult = VERIFY_INCORRECT_PASSWORD;
+                                       } else {
+                                            mVerifyResult = VERIFY_RESULT_EXCEPTION;
+                                       }
+                                    } else {
+                                        mVerifyResult = VERIFY_RESULT_PASS;
+                                    }
+                                    mDone = true;
+                                    UnlockSim.this.notifyAll();
+                                }
+                                break;
+                        }
+                    }
+                };
+                UnlockSim.this.notifyAll();
+            }
+            Looper.loop();
+        }
+
+        synchronized Bundle queryNetworkLock(int category) {
+
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            log("Enter queryNetworkLock");
+            Message callback = Message.obtain(mHandler, QUERY_NETWORK_STATUS_COMPLETE);
+            mSimCard.queryIccNetworkLock(category, callback);
+
+            while (!mDone) {
+                try {
+                    log("wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            Bundle bundle = new Bundle();
+            bundle.putBoolean(QUERY_SIMME_LOCK_RESULT, mResult);
+            bundle.putInt(SIMME_LOCK_LEFT_COUNT, mSIMMELockRetryCount);
+
+            log("done");
+            return bundle;
+        }
+
+        synchronized int supplyNetworkLock(String strPasswd) {
+
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            log("Enter supplyNetworkLock");
+            Message callback = Message.obtain(mHandler, SET_NETWORK_LOCK_COMPLETE);
+            mSimCard.supplyNetworkDepersonalization(strPasswd, callback);
+
+            while (!mDone) {
+                try {
+                    log("wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            log("done");
+            return mVerifyResult;
+        }
+    }
+
+    public Bundle queryNetworkLock(int subId, int category) {
+        final UnlockSim queryNetworkLockState;
+
+        log("queryNetworkLock");
+
+        queryNetworkLockState = new UnlockSim(getPhone(subId).getIccCard());
+        queryNetworkLockState.start();
+
+        return queryNetworkLockState.queryNetworkLock(category);
+    }
+
+    public int supplyNetworkDepersonalization(int subId, String strPasswd) {
+        final UnlockSim supplyNetworkLock;
+
+        log("supplyNetworkDepersonalization");
+
+        supplyNetworkLock = new UnlockSim(getPhone(subId).getIccCard());
+        supplyNetworkLock.start();
+
+        return supplyNetworkLock.supplyNetworkLock(strPasswd);
+    }
+
+    /**
+     * Modem SML change feature.
+     * This function will query the SIM state of the given slot. And broadcast
+     * ACTION_UNLOCK_SIM_LOCK if the SIM state is in network lock.
+     *
+     * @param subId: Indicate which sub to query
+     * @param needIntent: The caller can deside to broadcast ACTION_UNLOCK_SIM_LOCK or not
+     *                    in this time, because some APs will receive this intent (eg. Keyguard).
+     *                    That can avoid this intent to effect other AP.
+     */
+    public void repollIccStateForNetworkLock(int subId, boolean needIntent) {
+        if (TelephonyManager.getDefault().getPhoneCount() > 1) {
+            getPhone(subId).getIccCard().repollIccStateForModemSmlChangeFeatrue(needIntent);
+        } else {
+            log("Not Support in Single SIM.");
+        }
+    }
+
+    private static class SetMsisdn extends Thread {
+        private int mSubId;
+        private Phone myPhone;
+        private boolean mDone = false;
+        private int mResult = 0;
+        private Handler mHandler;
+
+        private static final String DEFAULT_ALPHATAG = "Default Tag";
+        private static final int CMD_SET_MSISDN_COMPLETE = 100;
+
+
+        public SetMsisdn(Phone myP, int subId) {
+            mSubId = subId;
+            myPhone = myP;
+        }
+
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            synchronized (SetMsisdn.this) {
+                mHandler = new Handler() {
+                    @Override
+                    public void handleMessage(Message msg) {
+                        AsyncResult ar = (AsyncResult) msg.obj;
+                        switch (msg.what) {
+                            case CMD_SET_MSISDN_COMPLETE:
+                                synchronized (SetMsisdn.this) {
+                                    if (ar.exception != null) { //Query exception occurs
+                                        Log.e(LOG_TAG, "Set msisdn fail");
+                                        mDone = true;
+                                        mResult = 0;
+                                    } else {
+                                        Log.d(LOG_TAG, "Set msisdn success");
+                                        mDone = true;
+                                        mResult = 1;
+                                    }
+                                    SetMsisdn.this.notifyAll();
+                                }
+                                break;
+                        }
+                    }
+                };
+                SetMsisdn.this.notifyAll();
+            }
+            Looper.loop();
+        }
+
+        synchronized int setLine1Number(String alphaTag, String number) {
+
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            Log.d(LOG_TAG, "Enter setLine1Number");
+            Message callback = Message.obtain(mHandler, CMD_SET_MSISDN_COMPLETE);
+            String myTag = alphaTag;
+
+            myTag = myPhone.getLine1AlphaTag();
+
+            if (myTag == null || myTag.equals("")) {
+                myTag = DEFAULT_ALPHATAG;
+            }
+
+            Log.d(LOG_TAG, "sub = " + mSubId + ", Tag = " + myTag + " ,number = " + number);
+
+            myPhone.setLine1Number(myTag, number, callback);
+
+
+            while (!mDone) {
+                try {
+                    Log.d(LOG_TAG, "wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            Log.d(LOG_TAG, "done");
+            return mResult;
+        }
+    }
+
+    //@Override
+    public int setLine1Number(int subId, String alphaTag, String number) {
+        if (DBG) log("setLine1NumberUsingSubId, subId " + subId);
+        if (number == null) {
+            loge("number = null");
+            return 0;
+        }
+        if (subId <= 0) {
+            loge("Error subId: " + subId);
+            return 0;
+        }
+
+        final SetMsisdn setMsisdn;
+
+        setMsisdn = new SetMsisdn(getPhone(subId), subId);
+        setMsisdn.start();
+
+        return setMsisdn.setLine1Number(alphaTag, number);
+    }
+
+    /**
+    * Return true if the FDN of the ICC card is enabled
+    */
+    //@Override
+    public boolean isFdnEnabled(int subId) {
+        log("isFdnEnabled  subId=" + subId);
+
+        if (subId <= 0) {
+            loge("Error subId: " + subId);
+            return false;
+        }
+
+        /* We will rollback the temporary solution after SubscriptionManager merge to L1 */
+        Phone phone = getPhone(subId);
+        if (phone != null) {
+            return phone.getIccCard().getIccFdnEnabled();
+        } else {
+            return false;
+        }
+    }
+
+    //@Override
+    public String getIccCardType(int subId) {
+        if (DBG) log("getIccCardType  subId=" + subId);
+
+        Phone phone = getPhone(subId);
+        if (phone == null) {
+            if (DBG) log("getIccCardType(): phone is null");
+            return "";
+        }
+
+        return phone.getIccCard().getIccCardType();
+    }
+
+    /**
+     * Get SVLTE CardType by slot ID.
+     *
+     * @param slotId for card slot ID.
+     * @return int card type index.
+     */
+    //@Override
+    public int getSvlteCardType(int slotId) {
+        if (DBG) {
+            log("getSvlteCardType(): slotId=" + slotId);
+        }
+/*
+        Phone phone = getPhone(slotId);
+        if (phone == null) {
+            if (DBG) {
+                log("getSvlteCardType(): phone is null");
+            }
+            return 0;
+        }
+
+        return phone.getIccCard().getSvlteCardType();
+*/
+
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            UiccCard uiccCard = UiccController.getInstance().getUiccCard(slotId);
+            if (uiccCard != null) {
+                return uiccCard.getSvlteCardType();
+            } else {
+                if (DBG) {
+                    log("getSvlteCardType(): uiccCard is null");
+                }
+                return 0;
+            }
+        } else {
+            if (DBG) {
+                log("getSvlteCardType(): Non CdmaLteDcSupport.");
+            }
+            return 0;
+        }
+    }
+
+    //@Override
+    public boolean isAppTypeSupported(int slotId, int appType) {
+        if (DBG) log("isAppTypeSupported  slotId=" + slotId);
+
+        UiccCard uiccCard = UiccController.getInstance().getUiccCard(slotId);
+        if (uiccCard == null) {
+            if (DBG) log("isAppTypeSupported(): uiccCard is null");
+            return false;
+        }
+
+        return ((uiccCard.getApplicationByType(appType) == null) ?  false : true);
+    }
+
+    //@Override
+    public boolean isTestIccCard(int slotId) {
+        String mTestCard = null;
+
+        mTestCard = SystemProperties.get(PROPERTY_RIL_TEST_SIM[slotId], "");
+        if (DBG) log("isTestIccCard(): slot id =" + slotId + ", iccType = " + mTestCard);
+        return (mTestCard != null && mTestCard.equals("1"));
+    }
+
+    /**
+     * Gemini
+     * Returns the alphabetic name of current registered operator.
+     * <p>
+     * Availability: Only when user is registered to a network. Result may be
+     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if
+     * on a CDMA network).
+     */
+    @Deprecated
+    public String getNetworkOperatorNameGemini(int slotId) {
+        int subId = getSubIdBySlot(slotId);
+        if (DBG) log("Deprecated! getNetworkOperatorNameGemini simId = " + slotId + " ,sub = " + subId);
+        return getNetworkOperatorNameUsingSub(subId);
+    }
+
+    public String getNetworkOperatorNameUsingSub(int subId) {
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        String prop = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ALPHA, "");
+        if (DBG) log("getNetworkOperatorNameUsingSub sub = " + subId + " ,prop = " + prop);
+        return prop;
+    }
+
+    /**
+     * Gemini
+     * Returns the numeric name (MCC+MNC) of current registered operator.
+     * <p>
+     * Availability: Only when user is registered to a network. Result may be
+     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if
+     * on a CDMA network).
+     */
+    @Deprecated
+    public String getNetworkOperatorGemini(int slotId) {
+        int subId = getSubIdBySlot(slotId);
+        if (DBG) log("Deprecated! getNetworkOperatorGemini simId = " + slotId + " ,sub = " + subId);
+        return getNetworkOperatorUsingSub(subId);
+    }
+
+    public String getNetworkOperatorUsingSub(int subId) {
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        String prop = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_NUMERIC, "");
+        if (DBG) log("getNetworkOperatorUsingSub sub = " + subId + " ,prop = " + prop);
+        return prop;
+    }
+
+    /* BT SIM operation begin */
+    public int btSimapConnectSIM(int simId,  BtSimapOperResponse btRsp) {
+        Log.d(LOG_TAG, "btSimapConnectSIM, simId " + simId);
+        // MTK TODO
+        /*
+        Phone btPhone = getPhoneUsingPhoneId(simId);
+        if (btPhone == null) {
+            Log.e(LOG_TAG, "btSimapDisconnectSIM btPhone is null");
+            return -1;
+        }
+        final SendBtSimapProfile sendBtSapTh = SendBtSimapProfile.getInstance(btPhone);
+        sendBtSapTh.setBtOperResponse(btRsp);
+        if (sendBtSapTh.getState() == Thread.State.NEW) {
+          sendBtSapTh.start();
+        }
+        int ret = sendBtSapTh.btSimapConnectSIM(simId);
+        Log.d(LOG_TAG, "btSimapConnectSIM ret is " + ret + " btRsp.curType " + btRsp.getCurType()
+         + " suptype " + btRsp.getSupportType() + " atr " + btRsp.getAtrString());
+        return ret;
+        */
+        return 0;
+    }
+
+    public int btSimapDisconnectSIM() {
+        // MTK TODO
+        /*
+        int simId = UiccController.getInstance().getBtConnectedSimId();
+        Log.d(LOG_TAG, "btSimapDisconnectSIM, simId " + simId);
+        Phone btPhone = getPhoneUsingPhoneId(simId);
+        if (btPhone == null) {
+           Log.e(LOG_TAG, "btSimapDisconnectSIM btPhone is null");
+           return -1;
+        }
+        final SendBtSimapProfile sendBtSapTh = SendBtSimapProfile.getInstance(btPhone);
+        if (sendBtSapTh.getState() == Thread.State.NEW) {
+           sendBtSapTh.start();
+        }
+        return sendBtSapTh.btSimapDisconnectSIM();
+        */
+        return 0;
+    }
+
+    public int btSimapApduRequest(int type, String cmdAPDU,  BtSimapOperResponse btRsp) {
+        /*
+        int simId = UiccController.getInstance().getBtConnectedSimId();
+        Log.d(LOG_TAG, "btSimapApduRequest, simId " + simId);
+        Phone btPhone = getPhoneUsingPhoneId(simId);
+        if (btPhone == null) {
+          Log.e(LOG_TAG, "btSimapApduRequest btPhone is null");
+          return -1;
+        }
+        final SendBtSimapProfile sendBtSapTh = SendBtSimapProfile.getInstance(btPhone);
+        sendBtSapTh.setBtOperResponse(btRsp);
+        if (sendBtSapTh.getState() == Thread.State.NEW) {
+           sendBtSapTh.start();
+        }
+        return sendBtSapTh.btSimapApduRequest(type, cmdAPDU);
+        */
+        return 0;
+    }
+
+    public int btSimapResetSIM(int type,  BtSimapOperResponse btRsp) {
+        /*
+        int simId = UiccController.getInstance().getBtConnectedSimId();
+        Log.d(LOG_TAG, "btSimapResetSIM, simId " + simId);
+        Phone btPhone = getPhoneUsingPhoneId(simId);
+        if (btPhone == null) {
+          Log.e(LOG_TAG, "btSimapResetSIM btPhone is null");
+          return -1;
+        }
+        final SendBtSimapProfile sendBtSapTh = SendBtSimapProfile.getInstance(btPhone);
+        sendBtSapTh.setBtOperResponse(btRsp);
+        if (sendBtSapTh.getState() == Thread.State.NEW) {
+           sendBtSapTh.start();
+        }
+        return sendBtSapTh.btSimapResetSIM(type);
+        */
+        return 0;
+    }
+
+    public int btSimapPowerOnSIM(int type,  BtSimapOperResponse btRsp) {
+        /*
+        int simId = UiccController.getInstance().getBtConnectedSimId();
+        Log.d(LOG_TAG, "btSimapPowerOnSIM, simId " + simId);
+        Phone btPhone = getPhoneUsingPhoneId(simId);
+        if (btPhone == null) {
+          Log.e(LOG_TAG, "btSimapPowerOnSIM btPhone is null");
+          return -1;
+        }
+        final SendBtSimapProfile sendBtSapTh = SendBtSimapProfile.getInstance(btPhone);
+        sendBtSapTh.setBtOperResponse(btRsp);
+        if (sendBtSapTh.getState() == Thread.State.NEW) {
+           sendBtSapTh.start();
+        }
+        return sendBtSapTh.btSimapPowerOnSIM(type);
+        */
+        return 0;
+    }
+
+    public int btSimapPowerOffSIM() {
+        /*
+        int simId = UiccController.getInstance().getBtConnectedSimId();
+        Log.d(LOG_TAG, "btSimapPowerOffSIM, simId " + simId);
+        Phone btPhone = getPhoneUsingPhoneId(simId);
+        if (btPhone == null) {
+           Log.e(LOG_TAG, "btSimapPowerOffSIM btPhone is null");
+           return -1;
+        }
+        final SendBtSimapProfile sendBtSapTh = SendBtSimapProfile.getInstance(btPhone);
+        if (sendBtSapTh.getState() == Thread.State.NEW) {
+            sendBtSapTh.start();
+        }
+        return sendBtSapTh.btSimapPowerOffSIM();
+        */
+        return 0;
+    }
+
+    // MTK TODO
+    /*
+    private static class SendBtSimapProfile extends Thread {
+        private Phone mBtSapPhone;
+        private boolean mDone = false;
+        private String mStrResult = null;
+        private ArrayList mResult;
+        private int mRet = 1;
+        private BtSimapOperResponse mBtRsp;
+        private Handler mHandler;
+
+        private static SendBtSimapProfile sInstance;
+        static final Object sInstSync = new Object();
+        // For async handler to identify request type
+        private static final int BTSAP_CONNECT_COMPLETE = 300;
+        private static final int BTSAP_DISCONNECT_COMPLETE = 301;
+        private static final int BTSAP_POWERON_COMPLETE = 302;
+        private static final int BTSAP_POWEROFF_COMPLETE = 303;
+        private static final int BTSAP_RESETSIM_COMPLETE = 304;
+        private static final int BTSAP_TRANSFER_APDU_COMPLETE = 305;
+
+        public static SendBtSimapProfile getInstance(Phone phone) {
+            synchronized (sInstSync) {
+                if (sInstance == null) {
+                    sInstance = new SendBtSimapProfile(phone);
+                }
+            }
+            return sInstance;
+        }
+        private SendBtSimapProfile(Phone phone) {
+            mBtSapPhone = phone;
+            mBtRsp = null;
+        }
+
+
+        public void setBtOperResponse(BtSimapOperResponse btRsp) {
+            mBtRsp = btRsp;
+        }
+
+        private Phone getPhone(int subId) {
+            // FIXME: getPhone by subId
+            return null;
+        }
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            synchronized (SendBtSimapProfile.this) {
+                mHandler = new Handler() {
+                    @Override
+                    public void handleMessage(Message msg) {
+                        AsyncResult ar = (AsyncResult) msg.obj;
+                        switch (msg.what) {
+                            case BTSAP_CONNECT_COMPLETE:
+                                Log.d(LOG_TAG, "BTSAP_CONNECT_COMPLETE");
+                                synchronized (SendBtSimapProfile.this) {
+                                    if (ar.exception != null) {
+                                        CommandException ce = (CommandException) ar.exception;
+                                        if (ce.getCommandError() == CommandException.Error.BT_SAP_CARD_REMOVED) {
+                                            mRet = 4;
+                                        } else if (ce.getCommandError() == CommandException.Error.BT_SAP_NOT_ACCESSIBLE) {
+                                            mRet = 2;
+                                        } else {
+                                            mRet = 1;
+                                        }
+                                        Log.e(LOG_TAG, "Exception BTSAP_CONNECT, Exception:" + ar.exception);
+                                    } else {
+                                        mStrResult = (String) (ar.result);
+                                        Log.d(LOG_TAG, "BTSAP_CONNECT_COMPLETE  mStrResult " + mStrResult);
+                                        String[] splited = mStrResult.split(",");
+
+                                        try {
+                                            mBtRsp.setCurType(Integer.parseInt(splited[0].trim()));
+                                            mBtRsp.setSupportType(Integer.parseInt(splited[1].trim()));
+                                            mBtRsp.setAtrString(splited[2]);
+                                            Log.d(LOG_TAG, "BTSAP_CONNECT_COMPLETE curType " + mBtRsp.getCurType() + " SupType " + mBtRsp.getSupportType() + " ATR " + mBtRsp.getAtrString());
+                                        } catch (NumberFormatException e) {
+                                            Log.e(LOG_TAG, "NumberFormatException");
+                                        }
+
+                                        mRet = 0;
+                                        //log("BTSAP_CONNECT_COMPLETE curType " + (String)(mResult.get(0)) + " SupType " + (String)(mResult.get(1)) + " ATR " + (String)(mResult.get(2)));
+                                    }
+
+                                    //log("BTSAP_CONNECT_COMPLETE curType " + mBtRsp.getCurType() + " SupType " + mBtRsp.getSupportType() + " ATR " + mBtRsp.getAtrString());
+                                    mDone = true;
+                                    SendBtSimapProfile.this.notifyAll();
+                                }
+                                break;
+                            case BTSAP_DISCONNECT_COMPLETE:
+                                Log.d(LOG_TAG, "BTSAP_DISCONNECT_COMPLETE");
+                                synchronized (SendBtSimapProfile.this) {
+                                    if (ar.exception != null) {
+                                        CommandException ce = (CommandException) ar.exception;
+                                        if (ce.getCommandError() == CommandException.Error.BT_SAP_CARD_REMOVED) {
+                                            mRet = 4;
+                                        } else if (ce.getCommandError() == CommandException.Error.BT_SAP_NOT_ACCESSIBLE) {
+                                            mRet = 2;
+                                        } else {
+                                            mRet = 1;
+                                        }
+                                        Log.e(LOG_TAG, "Exception BTSAP_DISCONNECT, Exception:" + ar.exception);
+                                    } else {
+                                        mRet = 0;
+                                    }
+                                    Log.d(LOG_TAG, "BTSAP_DISCONNECT_COMPLETE result is " + mRet);
+                                    mDone = true;
+                                    SendBtSimapProfile.this.notifyAll();
+                                }
+                                break;
+                            case BTSAP_POWERON_COMPLETE:
+                                Log.d(LOG_TAG, "BTSAP_POWERON_COMPLETE");
+                                synchronized (SendBtSimapProfile.this) {
+                                    if (ar.exception != null) {
+                                        CommandException ce = (CommandException) ar.exception;
+                                        if (ce.getCommandError() == CommandException.Error.BT_SAP_CARD_REMOVED) {
+                                            mRet = 4;
+                                        } else if (ce.getCommandError() == CommandException.Error.BT_SAP_NOT_ACCESSIBLE) {
+                                            mRet = 2;
+                                        } else {
+                                            mRet = 1;
+                                        }
+                                        loge("Exception POWERON_COMPLETE, Exception:" + ar.exception);
+                                    } else {
+                                        mStrResult = (String) (ar.result);
+                                        Log.d(LOG_TAG, "BTSAP_POWERON_COMPLETE  mStrResult " + mStrResult);
+                                        String[] splited = mStrResult.split(",");
+
+                                        try {
+                                            mBtRsp.setCurType(Integer.parseInt(splited[0].trim()));
+                                            mBtRsp.setAtrString(splited[1]);
+                                            Log.d(LOG_TAG, "BTSAP_POWERON_COMPLETE curType " + mBtRsp.getCurType() + " ATR " + mBtRsp.getAtrString());
+                                        } catch (NumberFormatException e) {
+                                            Log.e(LOG_TAG, "NumberFormatException");
+                                        }
+                                        mRet = 0;
+                                    }
+
+                                    mDone = true;
+                                    SendBtSimapProfile.this.notifyAll();
+                                }
+                                break;
+                            case BTSAP_POWEROFF_COMPLETE:
+                                Log.d(LOG_TAG, "BTSAP_POWEROFF_COMPLETE");
+                                synchronized (SendBtSimapProfile.this) {
+                                    if (ar.exception != null) {
+                                        CommandException ce = (CommandException) ar.exception;
+                                        if (ce.getCommandError() == CommandException.Error.BT_SAP_CARD_REMOVED) {
+                                            mRet = 4;
+                                        } else if (ce.getCommandError() == CommandException.Error.BT_SAP_NOT_ACCESSIBLE) {
+                                            mRet = 2;
+                                        } else {
+                                            mRet = 1;
+                                        }
+                                        Log.e(LOG_TAG, "Exception BTSAP_POWEROFF, Exception:" + ar.exception);
+                                    } else {
+                                        mRet = 0;
+                                    }
+                                    Log.d(LOG_TAG, "BTSAP_POWEROFF_COMPLETE result is " + mRet);
+                                    mDone = true;
+                                    SendBtSimapProfile.this.notifyAll();
+                                }
+                                break;
+                            case BTSAP_RESETSIM_COMPLETE:
+                                Log.d(LOG_TAG, "BTSAP_RESETSIM_COMPLETE");
+                                synchronized (SendBtSimapProfile.this) {
+                                    if (ar.exception != null) {
+                                        CommandException ce = (CommandException) ar.exception;
+                                        if (ce.getCommandError() == CommandException.Error.BT_SAP_CARD_REMOVED) {
+                                            mRet = 4;
+                                        } else if (ce.getCommandError() == CommandException.Error.BT_SAP_NOT_ACCESSIBLE) {
+                                            mRet = 2;
+                                        } else {
+                                            mRet = 1;
+                                        }
+                                        loge("Exception BTSAP_RESETSIM, Exception:" + ar.exception);
+                                    } else {
+                                        mStrResult = (String) (ar.result);
+                                        Log.d(LOG_TAG, "BTSAP_RESETSIM_COMPLETE  mStrResult " + mStrResult);
+                                        String[] splited = mStrResult.split(",");
+
+                                        try {
+                                            mBtRsp.setCurType(Integer.parseInt(splited[0].trim()));
+                                            mBtRsp.setAtrString(splited[1]);
+                                            Log.d(LOG_TAG, "BTSAP_RESETSIM_COMPLETE curType " + mBtRsp.getCurType() + " ATR " + mBtRsp.getAtrString());
+                                        } catch (NumberFormatException e) {
+                                            Log.e(LOG_TAG, "NumberFormatException");
+                                        }
+                                        mRet = 0;
+                                    }
+
+                                    mDone = true;
+                                    SendBtSimapProfile.this.notifyAll();
+                                }
+                                break;
+                            case BTSAP_TRANSFER_APDU_COMPLETE:
+                                Log.d(LOG_TAG, "BTSAP_TRANSFER_APDU_COMPLETE");
+                                synchronized (SendBtSimapProfile.this) {
+                                    if (ar.exception != null) {
+                                        CommandException ce = (CommandException) ar.exception;
+                                        if (ce.getCommandError() == CommandException.Error.BT_SAP_CARD_REMOVED) {
+                                            mRet = 4;
+                                        } else if (ce.getCommandError() == CommandException.Error.BT_SAP_NOT_ACCESSIBLE) {
+                                            mRet = 2;
+                                        } else {
+                                            mRet = 1;
+                                        }
+
+                                        Log.e(LOG_TAG, "Exception BTSAP_TRANSFER_APDU, Exception:" + ar.exception);
+                                    } else {
+                                        mBtRsp.setApduString((String) (ar.result));
+                                        Log.d(LOG_TAG, "BTSAP_TRANSFER_APDU_COMPLETE result is " + mBtRsp.getApduString());
+                                        mRet = 0;
+                                    }
+
+                                    mDone = true;
+                                    SendBtSimapProfile.this.notifyAll();
+                                }
+                                break;
+                        }
+                    }
+                };
+                SendBtSimapProfile.this.notifyAll();
+            }
+            Looper.loop();
+        }
+
+        synchronized int btSimapConnectSIM(int simId) {
+            int ret = 0;
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+            mDone = false;
+            Message callback = Message.obtain(mHandler, BTSAP_CONNECT_COMPLETE);
+            mBtSapPhone.sendBtSimProfile(0, 0, null, callback);
+
+            while (!mDone) {
+                try {
+                    Log.d(LOG_TAG, "wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            Log.d(LOG_TAG, "done");
+            if (mRet == 0) {
+                // parse result
+                UiccController.getInstance().setBtConnectedSimId(simId);
+                Log.d(LOG_TAG, "synchronized btSimapConnectSIM connect Sim is "
+                            + UiccController.getInstance().getBtConnectedSimId());
+                Log.d(LOG_TAG, "btSimapConnectSIM curType " + mBtRsp.getCurType() + " SupType "
+                        + mBtRsp.getSupportType() + " ATR " + mBtRsp.getAtrString());
+            } else {
+                ret = mRet;
+            }
+
+            Log.d(LOG_TAG, "synchronized btSimapConnectSIM ret " + ret);
+            return ret;
+        }
+
+        synchronized int btSimapDisconnectSIM() {
+            int ret = 0;
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+            Log.d(LOG_TAG, "synchronized btSimapDisconnectSIM");
+            mDone = false;
+            Message callback = Message.obtain(mHandler, BTSAP_DISCONNECT_COMPLETE);
+            final int slotId = UiccController.getInstance().getBtConnectedSimId();
+            // TODO: Wait for GeminiUtils ready
+            /*
+            if (!GeminiUtils.isValidSlot(slotId)) {
+                ret = 7; // No sim has been connected
+                return ret;
+            }
+            * /
+            mBtSapPhone.sendBtSimProfile(1, 0, null, callback);
+
+            while (!mDone) {
+                try {
+                    Log.d(LOG_TAG, "wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+            Log.d(LOG_TAG, "done");
+            if (mRet == 0) {
+                UiccController.getInstance().setBtConnectedSimId(-1);
+            }
+            ret = mRet;
+            Log.d(LOG_TAG, "synchronized btSimapDisconnectSIM ret " + ret);
+            return ret;
+        }
+
+        synchronized int btSimapResetSIM(int type) {
+            int ret = 0;
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+            mDone = false;
+            Message callback = Message.obtain(mHandler, BTSAP_RESETSIM_COMPLETE);
+
+            final int slotId = UiccController.getInstance().getBtConnectedSimId();
+            // TODO: Wait for GeminiUtils ready
+            /*
+            if (!GeminiUtils.isValidSlot(slotId)) {
+                ret = 7; // No sim has been connected
+                return ret;
+            }
+            * /
+            mBtSapPhone.sendBtSimProfile(4, type, null, callback);
+
+            while (!mDone) {
+                try {
+                    Log.d(LOG_TAG, "wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+            Log.d(LOG_TAG, "done");
+            if (mRet == 0)  {
+                Log.d(LOG_TAG, "btSimapResetSIM curType " + mBtRsp.getCurType() + " ATR " + mBtRsp.getAtrString());
+            } else {
+                ret = mRet;
+            }
+
+            Log.d(LOG_TAG, "synchronized btSimapResetSIM ret " + ret);
+            return ret;
+        }
+
+        synchronized int btSimapPowerOnSIM(int type)  {
+            int ret = 0;
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+            mDone = false;
+            Message callback = Message.obtain(mHandler, BTSAP_POWERON_COMPLETE);
+
+            final int slotId = UiccController.getInstance().getBtConnectedSimId();
+            // TODO: Wait for GeminiUtils ready
+            /*
+            if (!GeminiUtils.isValidSlot(slotId)) {
+                ret = 7; // No sim has been connected
+                return ret;
+            }
+            * /
+            mBtSapPhone.sendBtSimProfile(2, type, null, callback);
+
+            while (!mDone) {
+                try {
+                    Log.d(LOG_TAG, "wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+            Log.d(LOG_TAG, "done");
+            if (mRet == 0)  {
+                Log.d(LOG_TAG, "btSimapPowerOnSIM curType " + mBtRsp.getCurType() + " ATR " + mBtRsp.getAtrString());
+            } else {
+            ret = mRet;
+            }
+            Log.d(LOG_TAG, "synchronized btSimapPowerOnSIM ret " + ret);
+            return ret;
+        }
+
+        synchronized int btSimapPowerOffSIM() {
+            int ret = 0;
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+            mDone = false;
+            Message callback = Message.obtain(mHandler, BTSAP_POWEROFF_COMPLETE);
+
+            final int slotId = UiccController.getInstance().getBtConnectedSimId();
+            // TODO: Wait for GeminiUtils ready
+            /*
+            if (!GeminiUtils.isValidSlot(slotId)) {
+                ret = 7; // No sim has been connected
+                return ret;
+            }
+            * /
+            mBtSapPhone.sendBtSimProfile(3, 0, null, callback);
+
+            while (!mDone) {
+                try {
+                    Log.d(LOG_TAG, "wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+            Log.d(LOG_TAG, "done");
+            ret = mRet;
+            Log.d(LOG_TAG, "synchronized btSimapPowerOffSIM ret " + ret);
+            return ret;
+        }
+
+        synchronized int btSimapApduRequest(int type, String cmdAPDU) {
+            int ret = 0;
+            while (mHandler == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+            mDone = false;
+            Message callback = Message.obtain(mHandler, BTSAP_TRANSFER_APDU_COMPLETE);
+
+            final int slotId = UiccController.getInstance().getBtConnectedSimId();
+            // TODO: Wait for GeminiUtils ready
+            /*
+            if (!GeminiUtils.isValidSlot(slotId)) {
+                ret = 7; // No sim has been connected
+                return ret;
+            }
+            * /
+            Log.d(LOG_TAG, "btSimapApduRequest start " + type + ", mBtSapPhone " + mBtSapPhone);
+            mBtSapPhone.sendBtSimProfile(5, type, cmdAPDU, callback);
+
+            while (!mDone) {
+                try {
+                    Log.d(LOG_TAG, "wait for done");
+                    wait();
+                } catch (InterruptedException e) {
+                    // Restore the interrupted status
+                    Thread.currentThread().interrupt();
+                }
+            }
+            Log.d(LOG_TAG, "done");
+            if (mRet == 0)  {
+                Log.d(LOG_TAG, "btSimapApduRequest APDU " + mBtRsp.getApduString());
+            } else {
+                ret = mRet;
+            }
+
+            Log.d(LOG_TAG, "synchronized btSimapApduRequest ret " + ret);
+            return ret;
+        }
+    }
+    /* BT SIM operation end */
+
+    // MVNO-API START
+    // MTK TODO
+    public String getMvnoMatchType(int subId) {
+        /*
+        String type = getPhone(subId).getMvnoMatchType();
+        if (DBG) log("getMvnoMatchTypeUsingSub sub = " + subId + " ,vMailAlphaTag = " + type);
+        return type;
+        */
+        return null;
+    }
+
+    public String getMvnoPattern(int subId, String type) {
+        /*
+        String pattern = getPhone(subId).getMvnoPattern(type);
+        if (DBG) log("getMvnoPatternUsingSub sub = " + subId + " ,vMailAlphaTag = " + pattern);
+        return pattern;
+        */
+        return null;
+    }
+    // MVNO-API END
+
+    /**
+     * Make sure the caller has the READ_PRIVILEGED_PHONE_STATE permission.
+     *
+     * @throws SecurityException if the caller does not have the required permission
+     */
+    private void enforcePrivilegedPhoneStatePermission() {
+        mApp.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE,
+                null);
+    }
+
+    /**
+     * Request to run AKA authenitcation on UICC card by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteRand random challenge in byte array
+     * @param byteAutn authenication token in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    public byte[] simAkaAuthentication(int slotId, int family, byte[] byteRand, byte[] byteAutn) {
+        enforcePrivilegedPhoneStatePermission();
+
+        String strRand = "";
+        String strAutn = "";
+        log("simAkaAuthentication session is " + family + " simId " + slotId);
+
+        if (byteRand != null && byteRand.length > 0) {
+            strRand = IccUtils.bytesToHexString(byteRand).substring(0, byteRand.length * 2);
+        }
+
+        if (byteAutn != null && byteAutn.length > 0) {
+            strAutn = IccUtils.bytesToHexString(byteAutn).substring(0, byteAutn.length * 2);
+        }
+        log("simAkaAuthentication Randlen " + strRand.length() + " strRand is "
+                + strRand + ", AutnLen " + strAutn.length() + " strAutn " + strAutn);
+        String akaData = Integer.toHexString(strRand.length()) + strRand +
+                Integer.toHexString(strAutn.length()) + strAutn;
+        if (DBG) {
+            log("akaData: " + akaData);
+        }
+
+
+        int subId = getSubIdBySlot(slotId);
+        int appType = PhoneConstants.APPTYPE_UNKNOWN;
+        switch (family) {
+            case 1:
+                appType = PhoneConstants.APPTYPE_USIM;
+                break;
+            case 2:
+                appType = PhoneConstants.APPTYPE_CSIM;
+                break;
+            case 3:
+                appType = PhoneConstants.APPTYPE_ISIM;
+                break;
+        }
+        if (appType == PhoneConstants.APPTYPE_UNKNOWN) {
+            return null;
+        } else {
+            Context context = mPhone.getContext();
+            String responseData = TelephonyManager.from(context).getIccSimChallengeResponse(
+                       subId, appType, akaData);
+            return IccUtils.hexStringToBytes(responseData);
+        }
+    }
+
+    /**
+     * Request to run GBA authenitcation (Bootstrapping Mode)on UICC card
+     * by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteRand random challenge in byte array
+     * @param byteAutn authenication token in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    public byte[] simGbaAuthBootStrapMode(int slotId, int family, byte[] byteRand, byte[] byteAutn) {
+        enforcePrivilegedPhoneStatePermission();
+
+        if (mSimAuthThread == null) {
+            log("simGbaAuthBootStrapMode new thread");
+            mSimAuthThread = new SimAuth(mPhone);
+            mSimAuthThread.start();
+        } else {
+            log("simGbaAuthBootStrapMode thread has been created.");
+        }
+
+        String strRand = "";
+        String strAutn = "";
+        log("simGbaAuthBootStrapMode session is " + family + " simId " + slotId);
+
+        if (byteRand != null && byteRand.length > 0) {
+            strRand = IccUtils.bytesToHexString(byteRand).substring(0, byteRand.length * 2);
+        }
+
+        if (byteAutn != null && byteAutn.length > 0) {
+            strAutn = IccUtils.bytesToHexString(byteAutn).substring(0, byteAutn.length * 2);
+        }
+        log("simGbaAuthBootStrapMode strRand is " + strRand + " strAutn " + strAutn);
+
+        return mSimAuthThread.doGeneralSimAuth(slotId, family, 1, 0xDD, strRand, strAutn);
+    }
+
+    /**
+     * Request to run GBA authenitcation (NAF Derivation Mode)on UICC card
+     * by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteNafId network application function id in byte array
+     * @param byteImpi IMS private user identity in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    public byte[] simGbaAuthNafMode(int slotId, int family, byte[] byteNafId, byte[] byteImpi) {
+        enforcePrivilegedPhoneStatePermission();
+
+        if (mSimAuthThread == null) {
+            log("simGbaAuthNafMode new thread");
+            mSimAuthThread = new SimAuth(mPhone);
+            mSimAuthThread.start();
+        } else {
+            log("simGbaAuthNafMode thread has been created.");
+        }
+
+        String strNafId = "";
+        String strImpi = "";
+        log("simGbaAuthNafMode session is " + family + " simId " + slotId);
+
+        if (byteNafId != null && byteNafId.length > 0) {
+            strNafId = IccUtils.bytesToHexString(byteNafId).substring(0, byteNafId.length * 2);
+        }
+
+        /* ISIM GBA NAF mode parameter should be NAF_ID.
+         * USIM GAB NAF mode parameter should be NAF_ID + IMPI
+         * If getIccApplicationChannel got 0, mean that ISIM not support */
+        if (UiccController.getInstance().getIccApplicationChannel(slotId, family) == 0) {
+            log("simGbaAuthNafMode ISIM not support.");
+            if (byteImpi != null && byteImpi.length > 0) {
+                strImpi = IccUtils.bytesToHexString(byteImpi).substring(0, byteImpi.length * 2);
+            }
+        }
+        log("simGbaAuthNafMode NAF ID is " + strNafId + " IMPI " + strImpi);
+
+        return mSimAuthThread.doGeneralSimAuth(slotId, family, 1, 0xDE, strNafId, strImpi);
+    }
+
+    /**
+     * Since MTK keyguard has dismiss feature, we need to retrigger unlock event
+     * when user try to access the SIM card.
+     *
+     * @param subId inidicated subscription
+     *
+     * @return true represent broadcast a unlock intent to notify keyguard
+     *         false represent current state is not LOCKED state. No need to retrigger.
+     *
+     */
+    public boolean broadcastIccUnlockIntent(int subId) {
+        int state = TelephonyManager.getDefault().getSimState(SubscriptionManager.getSlotId(subId));
+
+        log("[broadcastIccUnlockIntent] subId:" + subId + " state: " + state);
+
+        String lockedReasion = "";
+
+        switch (state) {
+            case TelephonyManager.SIM_STATE_PIN_REQUIRED:
+                lockedReasion = IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN;
+                break;
+            case TelephonyManager.SIM_STATE_PUK_REQUIRED:
+                lockedReasion = IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK;
+                break;
+            case TelephonyManager.SIM_STATE_NETWORK_LOCKED:
+                switch (getPhone(subId).getIccCard().getNetworkPersoType()) {
+                    case PERSOSUBSTATE_SIM_NETWORK:
+                        lockedReasion = IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+                        break;
+                    case PERSOSUBSTATE_SIM_NETWORK_SUBSET:
+                        lockedReasion = IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+                        break;
+                    case PERSOSUBSTATE_SIM_CORPORATE:
+                        lockedReasion = IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+                        break;
+                    case PERSOSUBSTATE_SIM_SERVICE_PROVIDER:
+                        lockedReasion = IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+                        break;
+                    case PERSOSUBSTATE_SIM_SIM:
+                        lockedReasion = IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+                        break;
+                    default:
+                        lockedReasion = IccCardConstants.INTENT_VALUE_ICC_UNKNOWN;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        Intent intent = new Intent(TelephonyIntents.ACTION_UNLOCK_SIM_LOCK);
+
+        intent.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE,
+                         IccCardConstants.INTENT_VALUE_ICC_LOCKED);
+        intent.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON, lockedReasion);
+        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, SubscriptionManager.getPhoneId(subId));
+        log("[broadcastIccUnlockIntent] Broadcasting intent ACTION_UNLOCK_SIM_LOCK "
+            + " reason " + state + " for slotId : " + SubscriptionManager.getSlotId(subId));
+
+        mApp.sendBroadcastAsUser(intent, UserHandle.ALL);
+
+        return true;
+    }
+
+    /**
+     * Query if the radio is turned off by user.
+     *
+     * @param subId inidicated subscription
+     *
+     * @return true radio is turned off by user.
+     *         false radio isn't turned off by user.
+     *
+     */
+    public boolean isRadioOffBySimManagement(int subId) {
+        boolean result = true;
+        try {
+            Context otherAppsContext = mApp.createPackageContext(
+                    "com.android.phone", Context.CONTEXT_IGNORE_SECURITY);
+            SharedPreferences mIccidPreference =
+                    otherAppsContext.getSharedPreferences("RADIO_STATUS", 0);
+
+            Context context = mPhone.getContext();
+            SubscriptionInfo subInfo =
+                    SubscriptionManager.from(context).getActiveSubscriptionInfo(subId);
+            if ((subInfo != null) && (mIccidPreference != null)) {
+                log("[isRadioOffBySimManagement]SharedPreferences: "
+                        + mIccidPreference.getAll().size() + ", IccId: " + subInfo.getIccId());
+                result = mIccidPreference.contains(subInfo.getIccId());
+            }
+            log("[isRadioOffBySimManagement]result: " + result);
+        } catch (NameNotFoundException e) {
+            log("Fail to create com.android.phone createPackageContext");
+        }
+        return result;
+    }
+
+    // SIM switch
+    /**
+     * Get current phone capability
+     *
+     * @return the capability of phone. (@see PhoneConstants)
+     */
+    public int getPhoneCapability(int phoneId) {
+        //return PhoneConstants.CAPABILITY_34G;
+        return 0;
+    }
+
+    /**
+     * Set capability to phones
+     *
+     * @param phoneId phones want to change capability
+     * @param capability new capability for each phone
+     */
+    public void setPhoneCapability(int[] phoneId, int[] capability) {
+
+    }
+
+    /**
+     * To config SIM swap mode(for dsda).
+     *
+     * @return true if config SIM Swap mode successful, or return false
+     */
+    public boolean configSimSwap(boolean toSwapped) {
+        return true;
+    }
+
+    /**
+     * To check SIM is swapped or not(for dsda).
+     *
+     * @return true if swapped, or return false
+     */
+    public boolean isSimSwapped() {
+        return false;
+    }
+
+    /**
+     * To Check if Capability Switch Manual Control Mode Enabled.
+     *
+     * @return true if Capability Switch manual control mode is enabled, else false;
+     */
+    public boolean isCapSwitchManualEnabled() {
+        return true;
+    }
+
+    /**
+     * Get item list that will be displayed on manual switch setting
+     *
+     * @return String[] contains items
+     */
+    public String[] getCapSwitchManualList() {
+        return null;
+    }
+
+
+  /**
+     * To get located PLMN from sepcified SIM modem  protocol
+     * Returns current located PLMN string(ex: "46000") or null if not availble (ex: in flight mode or no signal area or this SIM is turned off)
+     * @param subId Indicate which SIM subscription to query
+     */
+    public String getLocatedPlmn(int subId) {
+        // MTK TODO
+        // return getPhone(subId).getLocatedPlmn();
+        return null;
+    }
+
+   /**
+     * Check if phone is hiding network temporary out of service state.
+     * @param subId Indicate which SIM subscription to query
+     * @return if phone is hiding network temporary out of service state.
+    */
+    public int getNetworkHideState(int subId) {
+        // MTK TODO
+        // return getPhone(subId).getNetworkHideState();
+        return 0;
+    }
+
+   /**
+     * Get the network service state for specified SIM.
+     * @param subId Indicate which SIM subscription to query
+     * @return service state.
+     */
+    public Bundle getServiceState(int subId) {
+        Phone phone = getPhone(subId);
+        if (phone != null) {
+            Bundle data = new Bundle();
+            phone.getServiceState().fillInNotifierBundle(data);
+            return data;
+        } else {
+            log("Can't not get phone");
+            return null;
+        }
+    }
+
+    /**
+     * Helper thread to turn async call to {@link #SimAuthentication} into
+     * a synchronous one.
+     */
+    private static class SimAuth extends Thread {
+        private Phone mTargetPhone;
+        private boolean mDone = false;
+        private IccIoResult mResponse = null;
+
+        // For replies from SimCard interface
+        private Handler mHandler;
+
+        // For async handler to identify request type
+        private static final int SIM_AUTH_GENERAL_COMPLETE = 300;
+
+        public SimAuth(Phone phone) {
+            mTargetPhone = phone;
+        }
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            synchronized (SimAuth.this) {
+                mHandler = new Handler() {
+                    @Override
+                    public void handleMessage(Message msg) {
+                        AsyncResult ar = (AsyncResult) msg.obj;
+                        switch (msg.what) {
+                            case SIM_AUTH_GENERAL_COMPLETE:
+                                log("SIM_AUTH_GENERAL_COMPLETE");
+                                synchronized (SimAuth.this) {
+                                    if (ar.exception != null) {
+                                        log("SIM Auth Fail");
+                                        mResponse = (IccIoResult) (ar.result);
+                                    } else {
+                                        mResponse = (IccIoResult) (ar.result);
+                                    }
+                                    log("SIM_AUTH_GENERAL_COMPLETE result is " + mResponse);
+                                    mDone = true;
+                                    SimAuth.this.notifyAll();
+                                }
+                                break;
+                        }
+                    }
+                };
+                SimAuth.this.notifyAll();
+            }
+            Looper.loop();
+        }
+
+        byte[] doGeneralSimAuth(int slotId, int family, int mode, int tag,
+                String strRand, String strAutn) {
+           synchronized (SimAuth.this) {
+                while (mHandler == null) {
+                    try {
+                        SimAuth.this.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+
+                mDone = false;
+                mResponse = null;
+
+                Message callback = Message.obtain(mHandler, SIM_AUTH_GENERAL_COMPLETE);
+
+                int sessionId = UiccController.getInstance().getIccApplicationChannel(slotId, family);
+                log("family = " + family + ", sessionId = " + sessionId);
+
+                int[] subId = SubscriptionManager.getSubId(slotId);
+                if (subId == null) {
+                    log("slotId = " + slotId + ", subId is invalid.");
+                    return null;
+                } else {
+                    // MTK TODO
+                    // getPhone(subId[0]).doGeneralSimAuthentication(sessionId, mode, tag, strRand, strAutn, callback);
+                }
+
+                while (!mDone) {
+                    try {
+                        log("wait for done");
+                        SimAuth.this.wait();
+                    } catch (InterruptedException e) {
+                        // Restore the interrupted status
+                        Thread.currentThread().interrupt();
+                    }
+                }
+                int len = 0;
+                byte[] result = null;
+
+                if (mResponse != null) {
+                    // 2 bytes for sw1 and sw2
+                    len = 2 + ((mResponse.payload == null) ? 0 : mResponse.payload.length);
+                    result = new byte[len];
+
+                    if (mResponse.payload != null) {
+                        System.arraycopy(mResponse.payload, 0, result, 0, mResponse.payload.length);
+                    }
+
+                    result[len - 1] = (byte) mResponse.sw2;
+                    result[len - 2] = (byte) mResponse.sw1;
+
+                    // TODO: Should use IccUtils.bytesToHexString to print log info.
+                    //for (int i = 0; i < len ; i++) {
+                    //    log("Result = " + result[i]);
+                    //}
+                    //log("Result = " + new String(result));
+                } else {
+                    log("mResponse is null.");
+                }
+
+                log("done");
+                return result;
+            }
+        }
+    }
+
+   /**
+    * This function is used to get SIM phonebook storage information
+    * by sim id.
+    *
+    * @param simId Indicate which sim(slot) to query
+    * @return int[] which incated the storage info
+    *         int[0]; // # of remaining entries
+    *         int[1]; // # of total entries
+    *         int[2]; // # max length of number
+    *         int[3]; // # max length of alpha id
+    *
+    */
+    public int[] getAdnStorageInfo(int subId) {
+        Log.d(LOG_TAG, "getAdnStorageInfo " + subId);
+
+        if (SubscriptionManager.isValidSubscriptionId(subId) == true) {
+            if (mAdnInfoThread == null) {
+                Log.d(LOG_TAG, "getAdnStorageInfo new thread ");
+                mAdnInfoThread  = new QueryAdnInfoThread(subId);
+                mAdnInfoThread.start();
+            } else {
+                mAdnInfoThread.setSubId(subId);
+                Log.d(LOG_TAG, "getAdnStorageInfo old thread ");
+            }
+            return mAdnInfoThread.GetAdnStorageInfo();
+        } else {
+            Log.d(LOG_TAG, "getAdnStorageInfo subId is invalid.");
+            int[] recordSize;
+            recordSize = new int[4];
+            recordSize[0] = 0; // # of remaining entries
+            recordSize[1] = 0; // # of total entries
+            recordSize[2] = 0; // # max length of number
+            recordSize[3] = 0; // # max length of alpha id
+            return recordSize;
+        }
+    }
+
+    private static class QueryAdnInfoThread extends Thread {
+
+        private int mSubId;
+        private boolean mDone = false;
+        private int[] recordSize;
+
+        private Handler mHandler;
+
+        // For async handler to identify request type
+        private static final int EVENT_QUERY_PHB_ADN_INFO = 100;
+
+        public QueryAdnInfoThread(int subId) {
+            mSubId = subId;
+        }
+        public void setSubId(int subId) {
+            mSubId = subId;
+            mDone = false;
+        }
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            synchronized (QueryAdnInfoThread.this) {
+                mHandler = new Handler() {
+                    @Override
+                    public void handleMessage(Message msg) {
+                        AsyncResult ar = (AsyncResult) msg.obj;
+
+                        switch (msg.what) {
+                            case EVENT_QUERY_PHB_ADN_INFO:
+                                Log.d(LOG_TAG, "EVENT_QUERY_PHB_ADN_INFO");
+                                synchronized (QueryAdnInfoThread.this) {
+                                    mDone = true;
+                                    int[] info = (int[]) (ar.result);
+                                    if (info != null) {
+                                        recordSize = new int[4];
+                                        recordSize[0] = info[0]; // # of remaining entries
+                                        recordSize[1] = info[1]; // # of total entries
+                                        recordSize[2] = info[2]; // # max length of number
+                                        recordSize[3] = info[3]; // # max length of alpha id
+                                        Log.d(LOG_TAG, "recordSize[0]=" + recordSize[0] + ",recordSize[1]=" + recordSize[1] +
+                                                         "recordSize[2]=" + recordSize[2] + ",recordSize[3]=" + recordSize[3]);
+                                    }
+                                    else {
+                                        recordSize = new int[4];
+                                        recordSize[0] = 0; // # of remaining entries
+                                        recordSize[1] = 0; // # of total entries
+                                        recordSize[2] = 0; // # max length of number
+                                        recordSize[3] = 0; // # max length of alpha id
+                                    }
+                                    QueryAdnInfoThread.this.notifyAll();
+
+                                }
+                                break;
+                            }
+                      }
+                };
+                QueryAdnInfoThread.this.notifyAll();
+            }
+            Looper.loop();
+        }
+
+        public int[] GetAdnStorageInfo() {
+            // MTK TODO
+            /*
+            synchronized (QueryAdnInfoThread.this) {
+                while (mHandler == null) {
+                    try {
+                        QueryAdnInfoThread.this.wait();
+
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+                Message response = Message.obtain(mHandler, EVENT_QUERY_PHB_ADN_INFO);
+
+                getPhone(mSubId).queryPhbStorageInfo(RILConstants.PHB_ADN, response);
+
+                while (!mDone) {
+                    try {
+                        Log.d(LOG_TAG, "wait for done");
+                        QueryAdnInfoThread.this.wait();
+                    } catch (InterruptedException e) {
+                        // Restore the interrupted status
+                        Thread.currentThread().interrupt();
+                    }
+                }
+                Log.d(LOG_TAG, "done");
+                return recordSize;
+            }
+            */
+            return null;
+        }
+    }
+
+   /**
+    * This function is used to check if the SIM phonebook is ready
+    * by sim id.
+    *
+    * @param simId Indicate which sim(slot) to query
+    * @return true if phone book is ready.
+    *
+    */
+    public boolean isPhbReady(int subId) {
+        String strPhbReady = "false";
+        String strAllSimState = "";
+        String strCurSimState = "";
+        boolean isSimLocked = false;
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        int slotId = SubscriptionManager.getSlotId(subId);
+
+        if (SubscriptionManager.isValidSlotId(slotId) == true) {
+            strAllSimState = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
+
+            if ((strAllSimState != null) && (strAllSimState.length() > 0)) {
+                String values[] = strAllSimState.split(",");
+                if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
+                    strCurSimState = values[phoneId];
+                }
+            }
+
+            isSimLocked = (strCurSimState.equals("NETWORK_LOCKED") || strCurSimState.equals("PIN_REQUIRED")); //In PUK_REQUIRED state, phb can be accessed.
+
+            if (PhoneConstants.SIM_ID_2 == slotId) {
+                strPhbReady = SystemProperties.get("gsm.sim.ril.phbready.2", "false");
+            } else if (PhoneConstants.SIM_ID_3 == slotId) {
+                strPhbReady = SystemProperties.get("gsm.sim.ril.phbready.3", "false");
+            } else if (PhoneConstants.SIM_ID_4 == slotId) {
+                strPhbReady = SystemProperties.get("gsm.sim.ril.phbready.4", "false");
+            } else {
+                strPhbReady = SystemProperties.get("gsm.sim.ril.phbready", "false");
+            }
+        }
+
+        log("[isPhbReady] subId:" + subId + ", slotId: " + slotId + ", isPhbReady: " + strPhbReady + ",strSimState: " + strAllSimState);
+
+        return (strPhbReady.equals("true") && !isSimLocked);
+    }
+
+    public boolean isAirplanemodeAvailableNow() {
+        // MTK TODO
+        // return mApp.isAllowAirplaneModeChange();
+        return true;
+    }
+
+    // SMS parts
+    private class ScAddress {
+        public String mAddress;
+        public int mSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+
+        public ScAddress(int subId, String addr) {
+            mAddress = addr;
+            mSubId = subId;
+        }
+    }
+
+    /**
+     * Get service center address
+     *
+     * @param subId subscription identity
+     *
+     * @return service message center address
+     */
+    public Bundle getScAddressUsingSubId(int subId) {
+        log("getScAddressUsingSubId, subId: " + subId);
+
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        if (phoneId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            log("no corresponding phone id");
+            return null;
+        }
+
+        Bundle result = (Bundle) sendRequest(CMD_HANDLE_GET_SCA, subId);
+
+        log("getScAddressUsingSubId: exit with " + result.toString());
+
+        return result;
+    }
+
+    /**
+     * Set service message center address
+     *
+     * @param subId subscription identity
+     * @param address service message center addressto be set
+     *
+     * @return true for success, false for failure
+     */
+    public boolean setScAddressUsingSubId(int subId, String address) {
+        log("setScAddressUsingSubId, subId: " + subId);
+
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        if (phoneId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+            log("no corresponding phone id");
+            return false;
+        }
+
+        ScAddress scAddress = new ScAddress(subId, address);
+
+        Boolean result = (Boolean) sendRequest(CMD_HANDLE_SET_SCA, scAddress);
+
+        log("setScAddressUsingSubId: exit with " + result.booleanValue());
+        return result.booleanValue();
+    }
+    // SMS part end
+
+    /**
+     * This function will get DcFailCause with int format.
+     *
+     * @param apnType for geting which last error of apnType
+     * @param phoneId for getting the current using phone
+     * @return int: return int failCause value
+     */
+    public int getLastDataConnectionFailCause(String apnType, int phoneId) {
+        // MTK TODO
+        /*
+        DcFailCause failCause = PhoneFactory.getPhone(phoneId).
+                                    getLastDataConnectionFailCause(apnType);
+        return failCause.getErrorCode();
+        */
+        return 0;
+    }
+
+    /**
+     * This function will get link properties of input apn type.
+     *
+     * @param apnType input apn type for geting link properties
+     * @param phoneId for getting the current using phone
+     * @return LinkProperties: return correspondent link properties with input apn type
+     */
+    public LinkProperties getLinkProperties(String apnType, int phoneId) {
+        return PhoneFactory.getPhone(phoneId).getLinkProperties(apnType);
+    }
+
+    /**
+     * Set phone radio type and access technology.
+     *
+     * @param rafs an RadioAccessFamily array to indicate all phone's
+     *        new radio access family. The length of RadioAccessFamily
+     *        must equal to phone count.
+     * @return true if start setPhoneRat successfully.
+     */
+    @Override
+    public boolean setRadioCapability(RadioAccessFamily[] rafs) {
+        boolean ret = true;
+        try {
+            ProxyController.getInstance().setRadioCapability(rafs);
+        } catch (RuntimeException e) {
+            Log.w(LOG_TAG, "setRadioCapability: Runtime Exception");
+            e.printStackTrace();
+            ret = false;
+        }
+        return ret;
+    }
+
+    /**
+     * Check if under capability switching.
+     *
+     * @return true if switching
+     */
+    public boolean isCapabilitySwitching() {
+        // MTK TODO
+        // return ProxyController.getInstance().isCapabilitySwitching();
+        return false;
+    }
+
+    /// M: [C2K] Switch SVLTE RAT mode. @{
+    /**
+     * Switch SVLTE RAT mode.
+     * @param mode the RAT mode.
+     */
+    public void switchSvlteRatMode(int mode) {
+        // MTK TODO
+        // SvlteRatController.getInstance().setSvlteRatMode(mode, null);
+    }
+
+    /**
+     * Set SVLTE RAT mode.
+     * @param mode the RAT mode.
+     * @param subId subscription ID to be queried
+     */
+    public void setSvlteRatMode(int mode, int subId) {
+        // MTK TODO
+        /*
+        int phoneId = SvlteUtils.getSlotIdbySubId(subId);
+        if (PhoneFactory.getPhone(phoneId) instanceof SvltePhoneProxy) {
+            SvltePhoneProxy svltePhoneProxy = (SvltePhoneProxy) PhoneFactory
+                    .getPhone(phoneId);
+            svltePhoneProxy.getSvlteRatController().setSvlteRatMode(mode, null);
+        }
+        */
+    }
+
+    /// M: [SVLTE] Get the ServiceState for Svlte. @{
+    /**
+     * This function will get the ServiceState for Svlte.
+     * @param subId for getting the current ServiceState for Svlte.
+     * @return service state.
+     *
+     * @hide
+     */
+    public Bundle getSvlteServiceState(int subId) {
+        // MTK TODO
+        /*
+        if (getPhone(subId).getSvlteServiceState() != null) {
+            Bundle data = new Bundle();
+            getPhone(subId).getSvlteServiceState().fillInNotifierBundle(data);
+            return data;
+        }
+        */
+        return null;
+    }
+
+    /**
+     * Switch SVLTE RAT mode.
+     * @param mode the RAT mode.
+     */
+    public void switchRadioTechnology(int networkType) {
+        // MTK TODO
+        // SvlteRatController.getInstance().setRadioTechnology(networkType, null);
+    }
+
+    /**
+     * Set SVLTE Radio Technology.
+     * @param networkType the networktype want to switch.
+     * @param subId subscription ID to be queried
+     */
+    public void setRadioTechnology(int networkType, int subId) {
+        // MTK TODO
+        /*
+        int phoneId = SvlteUtils.getSlotIdbySubId(subId);
+        if (PhoneFactory.getPhone(phoneId) instanceof SvltePhoneProxy) {
+            SvltePhoneProxy svltePhoneProxy = (SvltePhoneProxy) PhoneFactory
+                    .getPhone(phoneId);
+            svltePhoneProxy.getSvlteRatController().setRadioTechnology(
+                    networkType, null);
+        }
+        */
+    }
+    /// @}
+
+    public void setTrmForPhone(int phoneId, int mode) {
+        CommandsInterface ci;
+        Phone phone = PhoneFactory.getPhone(phoneId);
+        if (phone != null) {
+            ci = ((PhoneBase) (((PhoneProxy) phone).getActivePhone())).mCi;
+            log("setTrmForPhone phoneId: " + phoneId + " mode:" + mode);
+            ci.setTrm(mode, null);
+        } else {
+            log("phone is null");
+        }
+    }
+
+    /**
+     * Get subscriber Id of LTE phone.
+     * @param subId the subId of CDMAPhone
+     * @return The subscriber Id of LTE phone.
+     *
+     * @hide
+     */
+    public String getSubscriberIdForLteDcPhone(int subId) {
+        int phoneId = SubscriptionManager.getPhoneId(subId);
+        log("getSubscriberIdForLteDcPhone, subId:" + subId + ", phoneId:" + phoneId);
+        String imsi = null;
+        try {
+            UiccController uc = UiccController.getInstance();
+            IccRecords records = uc.getIccRecords(phoneId, UiccController.APP_FAM_3GPP);
+            if (records != null) {
+                imsi = records.getIMSI();
+            } else {
+                log("getSubscriberIdForLteDcPhone, 3gpp records is null");
+            }
+        } catch (RuntimeException e) {
+            log("getSubscriberIdForLteDcPhone, UiccController is not ready");
+        }
+        log("getSubscriberIdForLteDcPhone, imsi of 3gpp:" + imsi);
+        return imsi;
+    }
+
+    /**
+     * For C2K get SVLTE imei.
+     * @param slotId slot id
+     * @return svlte imei.
+     *
+     * @hide
+     */
+    public String getSvlteImei(int slotId) {
+        // MTK TODO
+        /*
+        log("getSvlteImei slotId = " + slotId);
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            log("svlte featureoption is true getSvlteImei slotId = " + slotId);
+            if (PhoneFactory.getPhone(slotId) instanceof SvltePhoneProxy) {
+                SvltePhoneProxy svltePhoneProxy = (SvltePhoneProxy) PhoneFactory.getPhone(slotId);
+                return svltePhoneProxy.getLtePhone().getImei();
+            }
+        }
+        */
+        log("svlte featureoption is false getSvlteImei slotId = " + slotId);
+        return TelephonyManager.getDefault().getImei();
+    }
+
+    /**
+     * Get main capability phone id.
+     * @return The phone id with highest capability.
+     */
+    public int getMainCapabilityPhoneId() {
+        return RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+    }
+
+    /**
+     * For C2K Get the airplane mode allow change or not.
+     */
+    public boolean isAllowAirplaneModeChange() {
+        return isAirplanemodeAvailableNow();
+    }
+
+   /**
+     * Initialze external SIM service on phone process.
+     *
+     * @hide
+     */
+    public void initializeService(String serviceName) {
+        // FIXME: need to design a whitelist mechansim, only alloew some service to execute this.
+        if ("osi".equals(serviceName)) {
+            SystemProperties.set("ctl.start", serviceName);
+        }
+    }
+
+   /**
+     * Finalize external SIM service on phone process.
+     *
+     * @hide
+     */
+    public void finalizeService(String serviceName) {
+        // FIXME: need to design a whitelist mechansim, only alloew some service to execute this.
+        if ("osi".equals(serviceName)) {
+            SystemProperties.set("ctl.stop", serviceName);
+        }
+    }
+
+   /**
+     * Return the sim card if in home network.
+     *
+     * @param subId subscription ID to be queried.
+     * @return true if in home network.
+     * @hide
+     */
+    public boolean isInHomeNetwork(int subId) {
+        final int phoneId = SvlteUtils.getSlotIdbySubId(subId);
+        boolean isInHomeNetwork = false;
+        final Phone phone = PhoneFactory.getPhone(phoneId);
+        if (phone != null && phone instanceof PhoneProxy) {
+            final PhoneProxy phoneProxy = ((PhoneProxy) phone);
+            // MTK TODO
+            ServiceState serviceState = null;  // phoneProxy.getSvlteServiceState();
+            if (serviceState == null) {
+                serviceState = phoneProxy.getServiceState();
+            }
+            if (serviceState != null) {
+                isInHomeNetwork = inSameCountry(phoneId, serviceState.getVoiceOperatorNumeric());
+            }
+        }
+        log("isInHomeNetwork, subId=" + subId + " ,phoneId=" + phoneId
+                + " ,isInHomeNetwork=" + isInHomeNetwork);
+        return isInHomeNetwork;
+    }
+
+    /**
+     * Check ISO country by MCC to see if phone is roaming in same registered country.
+     *
+     * @param phoneId for which phone inSameCountry is returned
+     * @param operatorNumeric registered operator numeric
+     * @return true if in same country.
+     * @hide
+     */
+    private static final boolean inSameCountry(int phoneId, String operatorNumeric) {
+        if (TextUtils.isEmpty(operatorNumeric) || (operatorNumeric.length() < 5)
+                || (!TextUtils.isDigitsOnly(operatorNumeric))) {
+            // Not a valid network
+            log("inSameCountry, Not a valid network"
+                    + ", phoneId=" + phoneId + ", operatorNumeric=" + operatorNumeric);
+            return true;
+        }
+
+        final String homeNumeric = getHomeOperatorNumeric(phoneId);
+        if (TextUtils.isEmpty(homeNumeric) || (homeNumeric.length() < 5)
+                || (!TextUtils.isDigitsOnly(homeNumeric))) {
+            // Not a valid SIM MCC
+            log("inSameCountry, Not a valid SIM MCC"
+                    + ", phoneId=" + phoneId + ", homeNumeric=" + homeNumeric);
+            return true;
+        }
+
+        boolean inSameCountry = true;
+        final String networkMCC = operatorNumeric.substring(0, 3);
+        final String homeMCC = homeNumeric.substring(0, 3);
+        final String networkCountry = MccTable.countryCodeForMcc(Integer.parseInt(networkMCC));
+        final String homeCountry = MccTable.countryCodeForMcc(Integer.parseInt(homeMCC));
+        log("inSameCountry, phoneId=" + phoneId
+                + ", homeMCC=" + homeMCC
+                + ", networkMCC=" + networkMCC
+                + ", homeCountry=" + homeCountry
+                + ", networkCountry=" + networkCountry);
+        if (networkCountry.isEmpty() || homeCountry.isEmpty()) {
+            // Not a valid country
+            return true;
+        }
+        inSameCountry = homeCountry.equals(networkCountry);
+        if (inSameCountry) {
+            return inSameCountry;
+        }
+        // special same country cases
+        if ("us".equals(homeCountry) && "vi".equals(networkCountry)) {
+            inSameCountry = true;
+        } else if ("vi".equals(homeCountry) && "us".equals(networkCountry)) {
+            inSameCountry = true;
+        } else if ("cn".equals(homeCountry) && "mo".equals(networkCountry)) {
+            inSameCountry = true;
+        }
+
+        log("inSameCountry, phoneId=" + phoneId + ", inSameCountry=" + inSameCountry);
+        return inSameCountry;
+    }
+
+    /**
+     * Returns the Service Provider Name (SPN).
+     *
+     * @param phoneId for which HomeOperatorNumeric is returned
+     * @return the Service Provider Name (SPN)
+     * @hide
+     */
+    private static final String getHomeOperatorNumeric(int phoneId) {
+        String numeric = TelephonyManager.getDefault().getSimOperatorNumericForPhone(phoneId);
+        if (TextUtils.isEmpty(numeric)) {
+            numeric = SystemProperties.get("ro.cdma.home.operator.numeric", "");
+        }
+        log("getHomeOperatorNumeric, phoneId=" + phoneId + ", numeric=" + numeric);
+        return numeric;
+    }
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    public boolean setLteAccessStratumReport(boolean enabled) {
+        int phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        int dataPhoneId = SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultDataSubId());
+        Phone phone = PhoneFactory.getPhone(phoneId);
+        if (phone == null || phoneId != dataPhoneId) {
+            loge("setLteAccessStratumReport incorrect parameter [getMainPhoneId = "
+                    + RadioCapabilitySwitchUtil.getMainCapabilityPhoneId()
+                    + ", dataPhoneId = " + dataPhoneId + "]");
+            if (phoneId != dataPhoneId) {
+                if (DBG) {
+                    loge("setLteAccessStratumReport: MainPhoneId and dataPhoneId aren't the same");
+                }
+            }
+            return false;
+        }
+        if (DBG) log("setLteAccessStratumReport: enabled = " + enabled);
+        Boolean success = (Boolean) sendRequest(CMD_SET_LTE_ACCESS_STRATUM_STATE,
+                new Boolean(enabled), new Integer(phoneId));
+        if (DBG) log("setLteAccessStratumReport: success = " + success);
+        return success;
+
+    }
+
+    public boolean setLteUplinkDataTransfer(boolean isOn, int timeMillis) {
+        int state = 1;
+        int phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        int dataPhoneId = SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultDataSubId());
+        Phone phone = PhoneFactory.getPhone(phoneId);
+        if (phone == null || phoneId != dataPhoneId) {
+            loge("setLteUplinkDataTransfer incorrect parameter [getMainPhoneId = "
+                    + RadioCapabilitySwitchUtil.getMainCapabilityPhoneId()
+                    + ", dataPhoneId = " + dataPhoneId + "]");
+            if (phoneId != dataPhoneId) {
+                if (DBG) {
+                    loge("setLteUplinkDataTransfer: MainPhoneId and dataPhoneId aren't the same");
+                }
+            }
+            return false;
+        }
+        if (DBG) {
+            log("setLteUplinkDataTransfer: isOn = " + isOn
+                    + ", Tclose timer = " + (timeMillis/1000));
+        }
+        if (!isOn) state = (timeMillis/1000) << 16 | 0;
+        Boolean success = (Boolean) sendRequest(CMD_SET_LTE_UPLINK_DATA_TRANSFER_STATE,
+                new Integer(state), new Integer(phoneId));
+        if (DBG) log("setLteUplinkDataTransfer: success = " + success);
+        return success;
+    }
+
+    public String getLteAccessStratumState() {
+        int phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        int dataPhoneId = SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultDataSubId());
+        Phone phone = PhoneFactory.getPhone(phoneId);
+        String state = PhoneConstants.LTE_ACCESS_STRATUM_STATE_UNKNOWN;
+        // MTK TODO
+        /*
+        if (phone == null || phoneId != dataPhoneId) {
+            loge("getLteAccessStratumState incorrect parameter [getMainPhoneId = "
+                    + RadioCapabilitySwitchUtil.getMainCapabilityPhoneId()
+                    + ", dataPhoneId = " + dataPhoneId + "]");
+            if (phoneId != dataPhoneId) {
+                if (DBG) {
+                    loge("getLteAccessStratumState: MainPhoneId and dataPhoneId aren't the same");
+                }
+            }
+        } else {
+            PhoneBase phoneBase = (PhoneBase)(((PhoneProxy)phone).getActivePhone());
+            DcTrackerBase dcTracker = phoneBase.mDcTracker;
+            state = dcTracker.getLteAccessStratumState();
+        }
+        */
+        if (DBG) log("getLteAccessStratumState: " + state);
+        return state;
+    }
+
+    public boolean isSharedDefaultApn() {
+        int phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        int dataPhoneId = SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultDataSubId());
+        Phone phone = PhoneFactory.getPhone(phoneId);
+        boolean isSharedDefaultApn = false;
+        // MTK TODO
+        /*
+        if (phone == null || phoneId != dataPhoneId) {
+            loge("isSharedDefaultApn incorrect parameter [getMainPhoneId = "
+                    + RadioCapabilitySwitchUtil.getMainCapabilityPhoneId()
+                    + ", dataPhoneId = " + dataPhoneId + "]");
+            if (phoneId != dataPhoneId) {
+                if (DBG) loge("isSharedDefaultApn: MainPhoneId and dataPhoneId aren't the same");
+            }
+        } else {
+            PhoneBase phoneBase = (PhoneBase)(((PhoneProxy)phone).getActivePhone());
+            DcTrackerBase dcTracker = phoneBase.mDcTracker;
+            isSharedDefaultApn = dcTracker.isSharedDefaultApn();
+        }
+        */
+        if (DBG) log("isSharedDefaultApn: " + isSharedDefaultApn);
+        return isSharedDefaultApn;
+    }
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /**
+     * For C2K get SVLTE meid.
+     * @param slotId slot id
+     * @return svlte meid.
+     *
+     * @hide
+     */
+    public String getSvlteMeid(int slotId) {
+        // MTK TODO
+        /*
+        int cdmaSlotId = SvlteModeController.getCdmaSocketSlotId();
+        log("getSvlteMeid slotId = " + slotId + "  cdmaSlotId = " + cdmaSlotId);
+        if (cdmaSlotId == slotId) {
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                log("svlte featureoption is true getSvlteMeid slotId = " + slotId);
+                if (PhoneFactory.getPhone(slotId) instanceof SvltePhoneProxy) {
+                    SvltePhoneProxy svltePhoneProxy =
+                        (SvltePhoneProxy) PhoneFactory.getPhone(slotId);
+                    return svltePhoneProxy.getNLtePhone().getDeviceId();
+                }
+            }
+        }
+        */
+        log("svlte featureoption is false getSvlteMeid slotId = " + slotId);
+        return TelephonyManager.getDefault().getDeviceId(slotId);
+    }
+}
